<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YO&GO Events - System Spikera</title>
    <style>
        :root {
            --primary-color: #FF8C00;
            --secondary-color: #FF7000;
            --success-color: #28a745;
            --error-color: #dc3545;
            --warning-color: #ffc107;
            --light-bg: #f8f9fa;
            --border-color: #ddd;
            --text-color: #333;
            
            /* Kolory dystans√≥w */
            --distance-5k: #FF6B6B;
            --distance-10k: #4ECDC4;
            --distance-21k: #45B7D1;
            --distance-42k: #96CEB4;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.4;
            color: var(--text-color);
            background-color: #f5f5f5;
            padding: 8px;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            height: calc(100vh - 16px);
            display: flex;
            flex-direction: column;
        }
        
        /* Header */
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        header h1 {
            margin: 0;
            font-size: 24px;
        }
        
        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .header-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .header-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .config-toggle:hover {
            transform: rotate(90deg);
        }
        
        /* Status bar */
        .status-bar {
            background-color: var(--light-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--error-color);
        }
        
        .status-indicator.connected {
            background-color: var(--success-color);
        }

        /* Statistics bar */
        .statistics-bar {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 6px 15px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 11px;
            border-bottom: 2px solid var(--primary-color);
            position: relative;
            z-index: 10;
        }

        .stats-distances-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .stats-distance-group {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 10px;
            border-radius: 4px;
        }

        .stats-distance-name {
            font-weight: bold;
            color: var(--primary-color);
            font-size: 11px;
        }

        .stats-item {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .stats-label {
            color: #aaa;
            font-size: 10px;
        }

        .stats-value {
            font-weight: bold;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .stats-value.started {
            color: #3498db;
        }

        .stats-value.finished {
            color: #2ecc71;
        }

        .stats-value.on-course {
            color: #f39c12;
        }

        .stats-total {
            background: var(--primary-color);
            padding: 4px 12px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 11px;
            display: inline-block;
            align-self: flex-start;
        }

        /* Tabs */
        .tab-container {
            background-color: var(--light-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 0 20px;
        }
        
        .tabs {
            display: flex;
            gap: 5px;
        }
        
        .tab {
            background: transparent;
            border: none;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
        }
        
        .tab:hover {
            color: var(--primary-color);
            background: rgba(255, 140, 0, 0.1);
        }
        
        .tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        /* Main content */
        .main-content {
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        
        .tab-content {
            display: none;
            height: 100%;
            padding: 15px;
            overflow-y: auto;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Panel */
        .panel {
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .panel h2 {
            margin: 0 0 15px 0;
            font-size: 20px;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 8px;
        }
        
        /* Search */
        .search-section {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .search-input {
            flex: 1;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            font-size: 18px;
        }
        
        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(255, 140, 0, 0.2);
        }
        
        .search-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 12px 24px;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .search-btn:hover {
            background: var(--secondary-color);
        }
        
        /* Athlete display */
        .athlete-display {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            min-height: 120px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .athlete-row {
            background: white;
            border-radius: 8px;
            padding: 15px 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: grid;
            grid-template-columns: 80px 3fr 2fr 120px;
            gap: 20px;
            align-items: center;
            min-height: 70px;
            border-left: 4px solid var(--primary-color);
            transform: translateX(-100%);
            opacity: 0;
            animation: slideInFromLeft 0.5s ease forwards;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }
        
        .athlete-row:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .athlete-row.distance-5k {
            border-left-color: var(--distance-5k);
            border-left-width: 6px;
        }
        
        .athlete-row.distance-10k {
            border-left-color: var(--distance-10k);
            border-left-width: 6px;
        }
        
        .athlete-row.distance-21k {
            border-left-color: var(--distance-21k);
            border-left-width: 6px;
        }
        
        .athlete-row.distance-42k {
            border-left-color: var(--distance-42k);
            border-left-width: 6px;
        }
        
        .athlete-row.finish-time {
            background: linear-gradient(135deg, #fff 0%, #f0fff4 100%);
            border-left-color: var(--success-color);
            border-left-width: 6px;
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.3);
        }
        
        @keyframes slideInFromLeft {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .row-bib {
            font-size: 32px;
            font-weight: bold;
            color: var(--primary-color);
            text-align: center;
        }
        
        .row-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .row-name {
            font-size: 22px;
            font-weight: 600;
            color: #333;
            line-height: 1.2;
        }
        
        .row-city {
            font-size: 14px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .distance-badge {
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            background: #666;
        }
        
        .row-custom {
            font-size: 16px;
            color: #333;
            font-weight: 500;
            text-align: center;
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 6px;
        }
        
        .row-category {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
        }
        
        .row-time-result {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background: #f8f9fa;
        }
        
        .row-time-result.finish-time {
            background: var(--success-color);
            color: white;
            font-weight: bold;
            animation: finishFlash 0.5s ease;
        }
        
        .time-display {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
        }
        
        .place-display {
            font-size: 11px;
            margin-top: 3px;
        }
        
        @keyframes finishFlash {
            0% { transform: scale(1); background: var(--warning-color); }
            50% { transform: scale(1.05); background: var(--warning-color); }
            100% { transform: scale(1); background: var(--success-color); }
        }
        
        /* row-timestamp usuniƒôte - czas nie jest wy≈õwietlany */
        
        .waiting-state {
            text-align: center;
            color: rgba(0, 0, 0, 0.5);
            padding: 50px;
        }
        
        .waiting-state h3 {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: 300;
        }
        
        .waiting-state p {
            font-size: 16px;
            opacity: 0.7;
        }
        
        /* Results view */
        .results-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 15px;
        }
        
        .results-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .distance-tabs, .checkpoint-tabs, .category-tabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .distance-tab, .checkpoint-tab, .category-tab {
            background: var(--light-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px 16px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
        }
        
        .distance-tab.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .checkpoint-tab.active {
            background: var(--secondary-color);
            color: white;
            border-color: var(--secondary-color);
        }
        
        .category-tab.active {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }
        
        .checkpoint-info {
            background: var(--light-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px 15px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #666;
            text-align: center;
        }
        
        .checkpoint-distance {
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .results-table-container {
            flex: 1;
            overflow: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .results-table th,
        .results-table td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        .results-table th {
            background: var(--light-bg);
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .results-table tr:hover {
            background: var(--light-bg);
        }
        
        .results-table tr {
            cursor: pointer;
        }

        /* Winners panel */
        .winners-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 15px;
            padding: 15px;
        }

        .winners-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            padding: 10px 15px;
            background: var(--light-bg);
            border-radius: 8px;
        }

        .winners-status {
            font-size: 14px;
        }

        .winners-status .status-waiting {
            color: #666;
        }

        .winners-status .status-received {
            color: var(--success-color);
            font-weight: bold;
        }

        .winners-display-mode {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .winners-display-mode label {
            font-weight: bold;
        }

        .mode-btn {
            padding: 8px 15px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: white;
            color: var(--text-color);
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .mode-btn:hover {
            border-color: var(--primary-color);
        }

        .mode-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .winners-container {
            flex: 1;
            overflow: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: white;
        }

        .winners-waiting-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 300px;
            text-align: center;
            color: #666;
        }

        .winners-waiting-state h3 {
            font-size: 24px;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .winners-waiting-state p {
            font-size: 16px;
            margin: 5px 0;
        }

        .winners-waiting-state .hint {
            font-size: 13px;
            color: #999;
            margin-top: 15px;
        }

        .winner-category {
            margin-bottom: 0;
        }

        .winner-category-header {
            background: #2c3e50;
            color: white;
            padding: 10px 15px;
            font-size: 15px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 2px solid var(--primary-color);
        }

        .winner-category-header.open-category {
            background: #1a5f2a;
        }

        .winner-category-header.female {
            background: #8b1a5c;
        }

        .winner-category-header.male {
            background: #1a4a8b;
        }

        .winner-category-header.extra {
            background: #5a1a8b;
        }

        .winners-table-header {
            display: grid;
            grid-template-columns: 60px 1fr 150px 100px 80px;
            padding: 8px 15px;
            background: #e9ecef;
            font-weight: bold;
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            border-bottom: 1px solid var(--border-color);
        }

        .winner-row {
            display: grid;
            grid-template-columns: 60px 1fr 150px 100px 80px;
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        .winner-row:nth-child(even) {
            background: #fafafa;
        }

        .winner-row:hover {
            background: #fff3cd;
        }

        .winner-rank {
            font-size: 16px;
            font-weight: bold;
            text-align: center;
        }

        .winner-rank.gold {
            color: #b8860b;
            font-size: 18px;
        }
        .winner-rank.silver {
            color: #6c757d;
            font-size: 17px;
        }
        .winner-rank.bronze {
            color: #a0522d;
            font-size: 16px;
        }

        .winner-info {
            overflow: hidden;
        }

        .winner-name {
            font-size: 15px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .winner-hometown {
            font-size: 13px;
            color: #555;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .winner-time {
            font-size: 14px;
            font-weight: bold;
            font-family: 'Consolas', 'Courier New', monospace;
            color: #333;
        }

        .winner-bib {
            font-size: 14px;
            color: #333;
            text-align: center;
            font-weight: 500;
        }

        /* Config panel */
        .config-panel {
            position: absolute;
            top: 0;
            right: -350px;
            width: 350px;
            height: 100%;
            background: white;
            border-left: 1px solid var(--border-color);
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            transition: right 0.3s ease;
            z-index: 100;
            overflow-y: auto;
        }
        
        .config-panel.open {
            right: 0;
        }
        
        .config-header {
            background: var(--primary-color);
            color: white;
            padding: 15px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .config-content {
            padding: 20px;
        }
        
        .config-section {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 20px;
            margin-bottom: 20px;
        }
        
        .config-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .config-section h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        .config-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-weight: 500;
            font-size: 14px;
            color: var(--text-color);
        }
        
        input, select {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 14px;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(255, 140, 0, 0.2);
        }
        
        button {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 12px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: 500;
        }
        
        button:hover {
            background: var(--secondary-color);
        }
        
        button.secondary {
            background: #6c757d;
        }
        
        button.secondary:hover {
            background: #5a6268;
        }
        
        .status-message {
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status-message.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .hidden {
            display: none !important;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 140, 0, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Responsive design */
        @media (max-width: 1400px) {
            .athlete-row {
                grid-template-columns: 70px 2.5fr 1.5fr 100px;
                gap: 15px;
            }
        }
        
        @media (max-width: 768px) {
            .status-bar {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .tabs {
                flex-wrap: wrap;
            }
            
            .tab {
                padding: 10px 15px;
                font-size: 14px;
            }
            
            .config-panel {
                width: 100%;
                right: -100%;
            }
            
            .athlete-row {
                grid-template-columns: 1fr;
                gap: 8px;
                text-align: center;
                padding: 12px;
            }
            
            .row-name {
                font-size: 18px;
            }
            
            .row-custom {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üèÉ YO&GO Events - System Spikera</h1>
            <div class="header-controls">
                <button id="fullscreen-toggle" class="header-btn" title="Pe≈Çny ekran">‚õ∂</button>
                <button id="config-toggle" class="header-btn config-toggle" title="Konfiguracja">‚öô</button>
            </div>
        </header>
        
        <div class="status-bar">
            <div class="status-item">
                <div id="bridge-indicator" class="status-indicator"></div>
                <span id="bridge-status">Bridge: Roz≈ÇƒÖczony</span>
            </div>
            <div class="status-item">
                <div id="api-indicator" class="status-indicator"></div>
                <span id="api-status">API: Roz≈ÇƒÖczony</span>
            </div>
            <div class="status-item">
                <div id="refresh-indicator" class="status-indicator"></div>
                <span id="refresh-status">Auto-od≈õwie≈ºanie: Wy≈ÇƒÖczone</span>
            </div>
            <div class="status-item">
                <span id="event-info">Brak wydarzenia</span>
            </div>
            <div class="status-item">
                <span id="athlete-count">Zawodnicy: 0</span>
            </div>
        </div>

        <!-- Pasek statystyk zawodnik√≥w -->
        <div class="statistics-bar" id="statistics-bar">
            <div id="stats-container">
                <span style="color: #aaa;">≈Åadowanie statystyk...</span>
            </div>
        </div>

        <div class="tab-container">
            <div class="tabs">
                <button id="speaker-tab" class="tab active">üé§ Spiker</button>
                <button id="results-tab" class="tab">üèÜ Wyniki</button>
                <button id="winners-tab" class="tab">üèÖ Zwyciƒôzcy</button>
            </div>
        </div>
        
        <div class="main-content">
            <!-- Panel spikera -->
            <div id="speaker-content" class="tab-content active">
                <div class="panel">
                    <h2>üîç Wyszukiwanie i Wy≈õwietlanie</h2>
                    <div class="search-section">
                        <input type="text" id="search-input" class="search-input" 
                               placeholder="Wprowad≈∫ numer startowy lub nazwisko..." autocomplete="off">
                        <button id="search-btn" class="search-btn">Szukaj</button>
                    </div>
                    
                    <div id="athlete-display" class="athlete-display">
                        <div id="athletes-feed">
                            <div class="waiting-state" id="waiting-state">
                                <h3>üì± Oczekiwanie na dane</h3>
                                <p>Wpisz numer BIB lub pobierz dane z API</p>
                            </div>
                        </div>
                    </div>
                    
                    <div id="search-status" class="status-message hidden"></div>
                </div>
            </div>
            
            <!-- Panel wynik√≥w -->
            <div id="results-content" class="tab-content">
                <div class="results-view">
                    <div class="results-controls">
                        <div>
                            <label style="margin-right: 10px;">Dystanse:</label>
                            <div class="distance-tabs" id="distance-tabs">
                                <!-- Zak≈Çadki dystans√≥w bƒôdƒÖ tutaj -->
                            </div>
                        </div>
                        
                        <div>
                            <label style="margin-right: 10px;">Kategorie:</label>
                            <div class="category-tabs" id="category-tabs">
                                <!-- Zak≈Çadki kategorii bƒôdƒÖ tutaj -->
                            </div>
                        </div>
                        
                        <div>
                            <label style="margin-right: 10px;">Punkty kontrolne:</label>
                            <div class="checkpoint-tabs" id="checkpoint-tabs">
                                <!-- Zak≈Çadki punkt√≥w kontrolnych bƒôdƒÖ tutaj -->
                            </div>
                        </div>
                        
                        <div>
                            <button id="manual-refresh" class="search-btn" style="padding: 8px 16px; font-size: 14px;">üîÑ Od≈õwie≈º</button>
                        </div>
                    </div>
                    
                    <!-- Informacja o kilometra≈ºu punktu kontrolnego -->
                    <div id="checkpoint-info" class="checkpoint-info hidden">
                        Punkt kontrolny na <span class="checkpoint-distance">km ?</span> trasy
                    </div>
                    
                    <div class="results-table-container">
                        <table class="results-table" id="results-table">
                            <thead>
                                <tr>
                                    <th>Miejsce</th>
                                    <th>Nr</th>
                                    <th>Zawodnik</th>
                                    <th>Kategoria</th>
                                    <th>Miasto</th>
                                    <th>Klub</th>
                                    <th>Dystans</th>
                                    <th>Czas</th>
                                    <th>Punkty kontrolne</th>
                                </tr>
                            </thead>
                            <tbody id="results-tbody">
                                <tr>
                                    <td colspan="9" style="text-align: center; color: #666; padding: 40px;">
                                        Pobierz dane aby wy≈õwietliƒá wyniki
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Panel zwyciƒôzc√≥w -->
            <div id="winners-content" class="tab-content">
                <div class="winners-view">
                    <div class="winners-controls">
                        <div class="winners-status" id="winners-status">
                            <span class="status-waiting">‚è≥ Oczekiwanie na dane zwyciƒôzc√≥w z komputera...</span>
                        </div>
                        <div class="winners-display-mode">
                            <label>Tryb wy≈õwietlania:</label>
                            <button id="winners-mode-alternating" class="mode-btn active">Naprzemiennie (K‚ÜíM‚ÜíK16‚ÜíM16)</button>
                            <button id="winners-mode-grouped" class="mode-btn">Grupowane (wszystkie K, potem M)</button>
                        </div>
                    </div>

                    <div class="winners-container" id="winners-container">
                        <div class="winners-waiting-state">
                            <h3>üèÖ Oczekiwanie na dane zwyciƒôzc√≥w</h3>
                            <p>Dane zostanƒÖ przes≈Çane automatycznie z komputera przez sieƒá.</p>
                            <p class="hint">Komputer wysy≈Ça dane po wczytaniu pliku CSV z wynikami.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Panel konfiguracji -->
            <div id="config-panel" class="config-panel">
                <div class="config-header">
                    ‚öôÔ∏è Konfiguracja Systemu
                </div>
                <div class="config-content">
                    <div class="config-section">
                        <h3>üéØ Wydarzenie</h3>
                        <div class="config-form">
                            <div class="form-group">
                                <label for="event-id">ID Wydarzenia ChronoTrack:</label>
                                <input type="text" id="event-id" placeholder="Wprowad≈∫ ID wydarzenia">
                            </div>
                            <button id="load-data">Pobierz Dane Wydarzenia</button>
                            <div id="data-status" class="status-message hidden"></div>
                        </div>
                    </div>
                    
                    <div class="config-section">
                        <h3>üåê Po≈ÇƒÖczenie Bridge</h3>
                        <div class="config-form">
                            <div class="form-group">
                                <label for="bridge-ip">IP Address Bridge:</label>
                                <input type="text" id="bridge-ip" value="192.168.1.100" placeholder="192.168.1.100">
                            </div>
                            
                            <div class="form-group">
                                <label for="bridge-port">Port WebSocket:</label>
                                <input type="text" id="bridge-port" value="8081" placeholder="8081">
                            </div>
                            
                            <button id="connect-bridge">Po≈ÇƒÖcz z Bridge</button>
                            <div id="bridge-status-msg" class="status-message hidden"></div>
                        </div>
                    </div>
                    
                    <div class="config-section">
                        <h3>‚è±Ô∏è Ustawienia</h3>
                        <div class="config-form">
                            <div class="form-group">
                                <label for="block-time">Blokada czasowa (minuty):</label>
                                <input type="number" id="block-time" value="5" min="1" max="60">
                            </div>
                            
                            <div class="form-group">
                                <label for="refresh-interval">Od≈õwie≈ºanie danych (sekundy):</label>
                                <input type="number" id="refresh-interval" value="30" min="10" max="300">
                            </div>
                            
                            <button id="clear-blocked" class="secondary">Odblokuj Wszystkich</button>
                            <button id="save-config" class="secondary">Zapisz Ustawienia</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Konfiguracja aplikacji
        const config = {
            api: {
                clientId: '727dae7f',
                userId: 'lukasz@yogoevents.pl',
                userPass: 'f2b2f3082a9d2ae5091eb5920bee538dc01bb413',
                baseUrl: 'https://api.chronotrack.com',
                eventId: localStorage.getItem('spiker-event-id') || ''
            },
            bridge: {
                ip: localStorage.getItem('bridge-ip') || '192.168.1.100',
                port: localStorage.getItem('bridge-port') || '8081',
                connected: false,
                socket: null
            },
            settings: {
                blockTimeMinutes: parseInt(localStorage.getItem('block-time')) || 5,
                refreshInterval: parseInt(localStorage.getItem('refresh-interval')) || 30
            }
        };

        // Stan aktualnie wybranych filtr√≥w
        let currentFilters = {
            distance: null,
            checkpoint: null,
            category: null
        };

        // Cache danych
        const cache = {
            athletes: new Map(),
            results: new Map(),
            distances: [],
            categories: [],
            checkpoints: [],
            courseData: new Map(),
            eventInfo: null,
            recentReads: [],
            blockedAthletes: new Map(),
            totalReads: 0,
            uniqueAthletes: new Set(),
            displayedAthletes: [],
            removeTimers: new Map(),
            lastResultsUpdate: 0,
            pendingIndividualUpdates: new Set(),
            refreshTimers: {
                results: null,
                individual: new Map()
            },
            winners: [],
            winnersDisplayMode: 'alternating'
        };

        // Elementy UI
        const ui = {
            configToggle: document.getElementById('config-toggle'),
            configPanel: document.getElementById('config-panel'),
            fullscreenToggle: document.getElementById('fullscreen-toggle'),
            
            bridgeIndicator: document.getElementById('bridge-indicator'),
            bridgeStatus: document.getElementById('bridge-status'),
            apiIndicator: document.getElementById('api-indicator'),
            apiStatus: document.getElementById('api-status'),
            refreshIndicator: document.getElementById('refresh-indicator'),
            refreshStatus: document.getElementById('refresh-status'),
            eventInfo: document.getElementById('event-info'),
            athleteCount: document.getElementById('athlete-count'),
            
            speakerTab: document.getElementById('speaker-tab'),
            resultsTab: document.getElementById('results-tab'),
            winnersTab: document.getElementById('winners-tab'),
            speakerContent: document.getElementById('speaker-content'),
            resultsContent: document.getElementById('results-content'),
            winnersContent: document.getElementById('winners-content'),
            winnersContainer: document.getElementById('winners-container'),
            winnersStatus: document.getElementById('winners-status'),
            winnersModeAlternating: document.getElementById('winners-mode-alternating'),
            winnersModeGrouped: document.getElementById('winners-mode-grouped'),

            searchInput: document.getElementById('search-input'),
            searchBtn: document.getElementById('search-btn'),
            athleteDisplay: document.getElementById('athlete-display'),
            athletesFeed: document.getElementById('athletes-feed'),
            waitingState: document.getElementById('waiting-state'),
            searchStatus: document.getElementById('search-status'),
            
            eventId: document.getElementById('event-id'),
            bridgeIp: document.getElementById('bridge-ip'),
            bridgePort: document.getElementById('bridge-port'),
            blockTime: document.getElementById('block-time'),
            refreshInterval: document.getElementById('refresh-interval'),
            connectBridge: document.getElementById('connect-bridge'),
            loadData: document.getElementById('load-data'),
            clearBlocked: document.getElementById('clear-blocked'),
            saveConfig: document.getElementById('save-config'),
            dataStatus: document.getElementById('data-status'),
            bridgeStatusMsg: document.getElementById('bridge-status-msg'),
            
            distanceTabs: document.getElementById('distance-tabs'),
            categoryTabs: document.getElementById('category-tabs'),
            checkpointTabs: document.getElementById('checkpoint-tabs'),
            resultsTable: document.getElementById('results-table'),
            resultsTbody: document.getElementById('results-tbody'),
            checkpointInfo: document.getElementById('checkpoint-info'),
            manualRefresh: document.getElementById('manual-refresh')
        };

        // Funkcje API ChronoTrack
        function buildApiUrl(endpoint, params = {}) {
            const authParams = {
                format: 'json',
                client_id: config.api.clientId,
                user_id: config.api.userId,
                user_pass: config.api.userPass,
                ...params
            };
            
            const queryString = Object.entries(authParams)
                .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
                .join('&');
            
            return `${config.api.baseUrl}${endpoint}?${queryString}`;
        }

        async function makeApiRequest(endpoint, params = {}) {
            try {
                const url = buildApiUrl(endpoint, params);
                console.log(`API Request: ${url.substring(0, 100)}...`);
                
                // Timeout po 3 sekundach - szybka odpowied≈∫ lub b≈ÇƒÖd
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000);
                
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP Error: ${response.status}`);
                }
                
                return await response.json();
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.error('API Request timeout after 3 seconds');
                } else {
                    console.error(`API Error: ${error.message}`);
                }
                throw error;
            }
        }

        // Pobieranie informacji o wydarzeniu
        async function fetchEventInfo() {
            try {
                const response = await makeApiRequest(`/api/event/${config.api.eventId}`);
                if (response && response.event) {
                    cache.eventInfo = {
                        id: response.event.event_id,
                        name: response.event.event_name,
                        date: formatEventDate(response.event.event_start_time),
                        location: response.event.location_city || ''
                    };
                    updateEventInfo();
                    return cache.eventInfo;
                }
                throw new Error('Invalid event data');
            } catch (error) {
                console.error(`Error fetching event info: ${error.message}`);
                throw error;
            }
        }

        // Pobieranie punkt√≥w kontrolnych z course API
        async function fetchCourseData() {
            try {
                const response = await makeApiRequest(`/api/event/${config.api.eventId}/course`);
                if (response && response.event_course) {
                    cache.courseData.clear();
                    
                    console.log('Course API response:', response.event_course);
                    
                    response.event_course.forEach(course => {
                        console.log(`Processing course: ${course.race_name || 'Unknown'}`);
                        
                        if (course.timing_points && Array.isArray(course.timing_points)) {
                            console.log(`Found ${course.timing_points.length} timing points`);
                            
                            course.timing_points.forEach(point => {
                                if (point.timing_point_name && point.timing_point_distance_from_start) {
                                    const distanceMeters = parseInt(point.timing_point_distance_from_start);
                                    const distanceKm = distanceMeters / 1000;
                                    
                                    cache.courseData.set(point.timing_point_name, {
                                        original_name: point.timing_point_name,
                                        distance_km: distanceKm,
                                        distance_meters: distanceMeters,
                                        race_name: course.race_name || '',
                                        display_name: `${distanceKm} km`
                                    });
                                    
                                    console.log(`Timing point: "${point.timing_point_name}" -> ${distanceKm}km (${distanceMeters}m)`);
                                }
                            });
                        } else {
                            console.log('No timing_points found in course');
                        }
                    });
                    
                    console.log(`Loaded ${cache.courseData.size} timing points from course data`);
                    
                    if (cache.courseData.size === 0) {
                        console.warn('Course API returned no timing points - will use checkpoint names from results API');
                    }
                    
                    return cache.courseData;
                }
                console.warn('No course data found in API response');
                return new Map();
            } catch (error) {
                console.error(`Error fetching course data: ${error.message}`);
                return new Map();
            }
        }

        // Pobieranie zawodnik√≥w
        async function fetchAllEntries() {
            try {
                let page = 1;
                let hasMore = true;
                const entries = new Map();

                while (hasMore && page <= 50) {
                    const params = {
                        page: page,
                        size: 50,
                        include_test_entries: true,
                        contact_details: true,
                        include_all_fields: true
                    };

                    const response = await makeApiRequest(`/api/event/${config.api.eventId}/entry`, params);
                    
                    if (response && response.event_entry && response.event_entry.length > 0) {
                        response.event_entry.forEach(entry => {
                            if (entry.entry_bib) {
                                const athlete = {
                                    bib: entry.entry_bib,
                                    firstName: entry.athlete_first_name || '',
                                    lastName: entry.athlete_last_name || '',
                                    city: entry.location_city || '',
                                    club: findClubField(entry) || '',
                                    distance: entry.race_distance || entry.race_name || '',
                                    category: entry.bracket_name || '',
                                    age: entry.entry_race_age || '',
                                    tag: entry.entry_tag || entry.entry_bib,
                                    sex: entry.athlete_sex || ''
                                };
                                entries.set(athlete.bib, athlete);
                            }
                        });

                        hasMore = response.event_entry.length >= 50;
                        page++;
                    } else {
                        hasMore = false;
                    }
                }

                cache.athletes = entries;
                console.log(`Loaded ${entries.size} athletes`);
                updateAthleteCount();
                return entries;
            } catch (error) {
                console.error(`Error fetching entries: ${error.message}`);
                throw error;
            }
        }

        // Znajdowanie pola klubu w custom fields
        function findClubField(entry) {
            for (const [key, value] of Object.entries(entry)) {
                if (key.startsWith('custom_element260') && value && value !== '' && value !== 'Tak') {
                    return value;
                }
            }
            
            for (const [key, value] of Object.entries(entry)) {
                if (key.startsWith('custom_element') && value && value !== '' && value !== 'Tak') {
                    const lowerValue = value.toLowerCase();
                    if (lowerValue.includes('klub') || lowerValue.includes('team') || 
                        lowerValue.includes('running') || lowerValue.includes('sport') ||
                        value.length > 3) {
                        return value;
                    }
                }
            }
            
            return '';
        }

        // Pobieranie wynik√≥w z hybrydowym systemem od≈õwie≈ºania
        async function fetchResults(mode = 'full') {
            try {
                const results = new Map();
                let page = 1;
                let hasMore = true;
                let totalCheckpointsFound = 0;
                let newResultsCount = 0;
                let updatedResultsCount = 0;

                // Okre≈õl strategiƒô pobierania na podstawie trybu i wielko≈õci zawod√≥w
                let maxPages = 100; // domy≈õlnie bez limitu
                let updateStrategy = 'replace'; // 'replace' lub 'merge'
                
                if (mode === 'quick') {
                    // Szybkie od≈õwie≈ºanie - sprawd≈∫ pierwszych 15 stron (1500 zawodnik√≥w)
                    // To powinno pokryƒá wiƒôkszo≈õƒá nowych wynik√≥w w trakcie zawod√≥w
                    maxPages = 15;
                    updateStrategy = 'merge';
                } else if (mode === 'full') {
                    // Pe≈Çne pobieranie - wszystkie wyniki
                    maxPages = 100;
                    updateStrategy = 'replace';
                }

                console.log(`Starting results fetch - Mode: ${mode}, Max pages: ${maxPages}, Strategy: ${updateStrategy}`);

                while (hasMore && page <= maxPages) {
                    const params = {
                        page: page,
                        size: 100,
                        interval: 'ALL'
                    };

                    const response = await makeApiRequest(`/api/event/${config.api.eventId}/results`, params);
                    
                    if (response && response.event_results && response.event_results.length > 0) {
                        response.event_results.forEach(result => {
                            const bib = result.results_bib;
                            const existingResult = cache.results.get(bib);
                            
                            if (!results.has(bib)) {
                                const newResult = {
                                    bib: bib,
                                    firstName: result.results_first_name,
                                    lastName: result.results_last_name,
                                    overallPlace: result.results_rank,
                                    categoryPlace: result.results_bracket_rank || result.results_division_rank || '',
                                    genderPlace: result.results_sex_rank || '',
                                    netTime: formatTime(result.results_time),
                                    gunTime: formatTime(result.results_gun_time),
                                    startTime: result.results_start_time || result.results_begin_chip_time || null,
                                    pace: result.results_pace,
                                    distance: result.results_race_name,
                                    category: result.results_primary_bracket_name,
                                    city: result.results_hometown || '',
                                    club: '',
                                    checkpoints: [],
                                    lastUpdated: Date.now()
                                };

                                results.set(bib, newResult);
                                
                                if (!existingResult) {
                                    newResultsCount++;
                                } else {
                                    // Por√≥wnaj czy sƒÖ zmiany w kluczowych polach
                                    if (existingResult.netTime !== newResult.netTime || 
                                        existingResult.overallPlace !== newResult.overallPlace ||
                                        existingResult.checkpoints.length !== newResult.checkpoints.length) {
                                        updatedResultsCount++;
                                    }
                                }
                            }

                            const intervalName = result.results_interval_name;
                            if (intervalName && intervalName !== 'Full Course' && intervalName !== 'Finish') {
                                const coursePoint = cache.courseData.get(intervalName);
                                const checkpoint = {
                                    name: intervalName,
                                    time: formatTime(result.results_time),
                                    place: result.results_rank,
                                    distance_km: coursePoint ? coursePoint.distance_km : null
                                };
                                
                                results.get(bib).checkpoints.push(checkpoint);
                                totalCheckpointsFound++;
                            }
                        });

                        hasMore = response.event_results.length >= 100;
                        page++;
                    } else {
                        hasMore = false;
                    }
                }

                // Aktualizuj cache wed≈Çug strategii
                if (updateStrategy === 'replace') {
                    // ZastƒÖp wszystkie wyniki (pe≈Çne od≈õwie≈ºanie)
                    cache.results = results;
                } else {
                    // Merge - dodaj/zaktualizuj tylko nowe wyniki (szybkie od≈õwie≈ºanie)
                    results.forEach((result, bib) => {
                        cache.results.set(bib, result);
                    });
                }

                cache.lastResultsUpdate = Date.now();
                
                console.log(`Results update completed - Mode: ${mode}, Pages fetched: ${page-1}, New: ${newResultsCount}, Updated: ${updatedResultsCount}, Total checkpoints: ${totalCheckpointsFound}, Total cached results: ${cache.results.size}`);
                
                if (mode === 'full') {
                    extractDistancesAndCheckpoints();
                }
                
                return results;
            } catch (error) {
                console.error(`Error fetching results: ${error.message}`);
                throw error;
            }
        }

        // Pobieranie indywidualnego wyniku zawodnika
        async function fetchIndividualResult(bib) {
            try {
                console.log(`Fetching individual result for BIB ${bib}`);
                
                const params = {
                    bib_number: bib,
                    interval: 'ALL'
                };

                const response = await makeApiRequest(`/api/event/${config.api.eventId}/results`, params);
                
                if (response && response.event_results && response.event_results.length > 0) {
                    const resultData = response.event_results[0];
                    
                    const result = {
                        bib: bib,
                        firstName: resultData.results_first_name,
                        lastName: resultData.results_last_name,
                        overallPlace: resultData.results_rank,
                        categoryPlace: resultData.results_bracket_rank || resultData.results_division_rank || '',
                        genderPlace: resultData.results_sex_rank || '',
                        netTime: formatTime(resultData.results_time),
                        gunTime: formatTime(resultData.results_gun_time),
                        startTime: resultData.results_start_time || resultData.results_begin_chip_time || null,
                        pace: resultData.results_pace,
                        distance: resultData.results_race_name,
                        category: resultData.results_primary_bracket_name,
                        city: resultData.results_hometown || '',
                        club: '',
                        checkpoints: [],
                        lastUpdated: Date.now()
                    };

                    // Dodaj checkpointy
                    response.event_results.forEach(res => {
                        const intervalName = res.results_interval_name;
                        if (intervalName && intervalName !== 'Full Course' && intervalName !== 'Finish') {
                            const coursePoint = cache.courseData.get(intervalName);
                            const checkpoint = {
                                name: intervalName,
                                time: formatTime(res.results_time),
                                place: res.results_rank,
                                distance_km: coursePoint ? coursePoint.distance_km : null
                            };
                            result.checkpoints.push(checkpoint);
                        }
                    });

                    // Aktualizuj cache
                    const oldResult = cache.results.get(bib);
                    cache.results.set(bib, result);
                    
                    console.log(`Updated individual result for BIB ${bib}: ${result.netTime}`);
                    
                    // Aktualizuj wy≈õwietlony wiersz je≈õli zawodnik jest aktualnie pokazany
                    updateDisplayedAthleteResult(bib, result);
                    
                    return result;
                } else {
                    console.log(`No result found for BIB ${bib}`);
                    return null;
                }
            } catch (error) {
                console.error(`Error fetching individual result for BIB ${bib}: ${error.message}`);
                return null;
            }
        }

        // Aktualizacja wyniku zawodnika na wy≈õwietlaczu spikera
        function updateDisplayedAthleteResult(bib, newResult) {
            cache.displayedAthletes.forEach(displayedAthlete => {
                const row = displayedAthlete.element;
                const bibElement = row.querySelector('.row-bib');
                
                if (bibElement && bibElement.textContent === bib) {
                    const timeResultElement = row.querySelector('.row-time-result');
                    
                    if (newResult.netTime && newResult.netTime !== '-') {
                        // Zawodnik uko≈Ñczy≈Ç - nie pokazujemy nic, tylko zielony pasek
                        row.classList.add('finish-time');

                        console.log(`Athlete BIB ${bib} finished`);
                    }
                }
            });
        }

        // Automatyczne od≈õwie≈ºanie wynik√≥w z inteligentnym systemem
        function startAutoRefresh() {
            // Zatrzymaj istniejƒÖce timery
            stopAutoRefresh();
            
            let quickRefreshCount = 0;
            const maxQuickRefreshes = 4; // Po 4 szybkich od≈õwie≈ºaniach r√≥b pe≈Çne
            
            // Timer dla hybrydowego od≈õwie≈ºania
            cache.refreshTimers.results = setInterval(async () => {
                if (cache.results.size > 0) {
                    try {
                        // Strategia od≈õwie≈ºania:
                        // - Pierwsze 4 cykle: szybkie od≈õwie≈ºanie (pierwsze 15 stron)
                        // - Co 5. cykl: pe≈Çne od≈õwie≈ºanie wszystkich wynik√≥w
                        // - Czas: co 30 sekund dla szybkiego, co 2.5 minuty pe≈Çne
                        
                        const useQuickRefresh = quickRefreshCount < maxQuickRefreshes;
                        const mode = useQuickRefresh ? 'quick' : 'full';
                        
                        console.log(`Auto-refresh cycle ${quickRefreshCount + 1}/${maxQuickRefreshes + 1} - Mode: ${mode}`);
                        
                        await fetchResults(mode);
                        updateResultsTable();
                        updateRefreshStatus(true, mode);
                        
                        if (useQuickRefresh) {
                            quickRefreshCount++;
                        } else {
                            quickRefreshCount = 0; // Reset counter po pe≈Çnym od≈õwie≈ºaniu
                        }
                        
                    } catch (error) {
                        console.error('Auto-refresh error:', error);
                        updateRefreshStatus(false);
                    }
                }
            }, 30000); // Co 30 sekund
            
            updateRefreshStatus(true, 'hybrid');
            console.log('Auto-refresh started: hybrid mode (quick every 30s, full every 2.5min)');
        }

        function stopAutoRefresh() {
            if (cache.refreshTimers.results) {
                clearInterval(cache.refreshTimers.results);
                cache.refreshTimers.results = null;
            }
            
            // Zatrzymaj wszystkie timery indywidualnych aktualizacji
            cache.refreshTimers.individual.forEach(timer => {
                clearTimeout(timer);
            });
            cache.refreshTimers.individual.clear();
            
            updateRefreshStatus(false);
            console.log('Auto-refresh stopped');
        }

        function updateRefreshStatus(active = false, mode = 'hybrid') {
            if (active) {
                ui.refreshIndicator.classList.add('connected');
                if (mode === 'quick') {
                    ui.refreshStatus.textContent = 'Auto-od≈õwie≈ºanie: Szybkie (15 stron)';
                } else if (mode === 'full') {
                    ui.refreshStatus.textContent = 'Auto-od≈õwie≈ºanie: Pe≈Çne (wszystkie)';
                } else {
                    ui.refreshStatus.textContent = 'Auto-od≈õwie≈ºanie: Hybrydowe (30s)';
                }
            } else {
                ui.refreshIndicator.classList.remove('connected');
                ui.refreshStatus.textContent = 'Auto-od≈õwie≈ºanie: Wy≈ÇƒÖczone';
            }
        }

        // Zaplanowanie indywidualnej aktualizacji zawodnika
        function scheduleIndividualUpdate(bib, delaySeconds = 0) {
            // Anuluj poprzedni timer dla tego zawodnika je≈õli istnieje
            if (cache.refreshTimers.individual.has(bib)) {
                clearTimeout(cache.refreshTimers.individual.get(bib));
            }
            
            // Dodaj do listy oczekujƒÖcych
            cache.pendingIndividualUpdates.add(bib);
            
            // Ustaw nowy timer
            const timer = setTimeout(async () => {
                if (cache.pendingIndividualUpdates.has(bib)) {
                    console.log(`Scheduled individual update for BIB ${bib}`);
                    await fetchIndividualResult(bib);
                    cache.pendingIndividualUpdates.delete(bib);
                    cache.refreshTimers.individual.delete(bib);
                }
            }, delaySeconds * 1000);
            
            cache.refreshTimers.individual.set(bib, timer);
            console.log(`Scheduled individual update for BIB ${bib} in ${delaySeconds}s`);
        }

        // WyciƒÖgniƒôcie dystans√≥w i punkt√≥w kontrolnych
        function extractDistancesAndCheckpoints() {
            const distances = new Set();
            const checkpointsMap = new Map();
            const categories = new Set();

            cache.results.forEach(result => {
                if (result.distance) {
                    distances.add(result.distance);
                }
                if (result.category) {
                    categories.add(result.category);
                }
                result.checkpoints.forEach(cp => {
                    const coursePoint = cache.courseData.get(cp.name);
                    
                    if (coursePoint) {
                        checkpointsMap.set(cp.name, {
                            name: cp.name,
                            distance_km: coursePoint.distance_km,
                            display_name: `${coursePoint.distance_km} km`,
                            has_distance: true
                        });
                    } else {
                        if (!checkpointsMap.has(cp.name)) {
                            checkpointsMap.set(cp.name, {
                                name: cp.name,
                                distance_km: null,
                                display_name: cp.name,
                                has_distance: false
                            });
                        }
                    }
                });
            });

            cache.distances = Array.from(distances);
            cache.categories = Array.from(categories).sort();
            
            const checkpointsWithDistance = Array.from(checkpointsMap.values())
                .filter(cp => cp.has_distance)
                .sort((a, b) => a.distance_km - b.distance_km);
            
            const checkpointsWithoutDistance = Array.from(checkpointsMap.values())
                .filter(cp => !cp.has_distance)
                .sort((a, b) => a.name.localeCompare(b.name));
            
            cache.checkpoints = [
                ...checkpointsWithDistance.map(cp => cp.name),
                ...checkpointsWithoutDistance.map(cp => cp.name)
            ];
            
            console.log('Extracted distances:', cache.distances);
            console.log('Extracted categories:', cache.categories);
            console.log('Extracted checkpoints:', cache.checkpoints);
            console.log(`Course data available: ${cache.courseData.size > 0 ? 'YES' : 'NO'}`);
            
            updateDistanceTabs();
            updateCategoryTabs();
            updateCheckpointTabs();
        }

        // Formatowanie czasu
        function formatTime(timeString) {
            if (!timeString) return '-';
            
            if (timeString.includes(':')) {
                const parts = timeString.split(':');
                const hours = parseInt(parts[0]);
                const minutes = parseInt(parts[1]);
                const seconds = parts[2] ? parseInt(parts[2].split('.')[0]) : 0;
                
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
            
            return timeString;
        }

        // Formatowanie daty wydarzenia
        function formatEventDate(timestamp) {
            if (!timestamp) return '-';
            try {
                const date = new Date(parseInt(timestamp) * 1000);
                return `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')}.${date.getFullYear()}`;
            } catch (error) {
                return timestamp;
            }
        }

        // Funkcje wy≈õwietlania zawodnik√≥w
        function getDistanceClass(distance) {
            if (!distance) return '';
            const normalized = distance.toLowerCase().replace(/[^a-z0-9]/g, '');
            if (normalized.includes('5k') || normalized.includes('5')) return 'distance-5k';
            if (normalized.includes('10k') || normalized.includes('10')) return 'distance-10k';
            if (normalized.includes('21k') || normalized.includes('21') || normalized.includes('polmaraton')) return 'distance-21k';
            if (normalized.includes('42k') || normalized.includes('42') || normalized.includes('maraton')) return 'distance-42k';
            return 'distance-other';
        }

        function getDistanceColor(distance) {
            const distanceClass = getDistanceClass(distance);
            switch(distanceClass) {
                case 'distance-5k': return '#FF6B6B';
                case 'distance-10k': return '#4ECDC4';
                case 'distance-21k': return '#45B7D1';
                case 'distance-42k': return '#96CEB4';
                default: return '#FF8C00';
            }
        }

        function createAthleteRow(athlete, result = null) {
            const row = document.createElement('div');
            const distanceClass = getDistanceClass(athlete.distance);
            row.className = `athlete-row ${distanceClass}`;
            
            const currentTime = new Date().toLocaleTimeString();
            
            // SUPER UPROSZCZONA WERSJA - tylko podstawowe dane, BEZ wynik√≥w
            // Wyniki mo≈ºna sprawdziƒá w zak≈Çadce "Wyniki"
            row.innerHTML = `
                <div class="row-bib">${athlete.bib}</div>
                <div class="row-info">
                    <div class="row-name">${athlete.firstName} ${athlete.lastName}</div>
                    <div class="row-city">
                        ${athlete.city || ''} 
                        <span class="distance-badge ${distanceClass}" style="background: ${getDistanceColor(athlete.distance)};">${athlete.distance}</span>
                    </div>
                </div>
                <div class="row-custom">${athlete.club || ''}</div>
                <div class="row-category">${athlete.category || 'OPEN'}</div>
            `;
            
            return row;
        }

        function addAthleteRow(athleteRow) {
            ui.waitingState.style.display = 'none';
            
            cache.displayedAthletes.unshift({
                element: athleteRow,
                timestamp: Date.now()
            });
            
            ui.athletesFeed.insertBefore(athleteRow, ui.athletesFeed.firstChild);
            
            const maxRows = 15;
            while (cache.displayedAthletes.length > maxRows) {
                removeOldestRow();
            }
        }

        function removeOldestRow() {
            if (cache.displayedAthletes.length === 0) return;
            const oldest = cache.displayedAthletes[cache.displayedAthletes.length - 1];
            removeAthleteRow(oldest.element);
        }

        function removeAthleteRow(rowElement) {
            const index = cache.displayedAthletes.findIndex(item => item.element === rowElement);
            if (index === -1) return;
            
            cache.displayedAthletes.splice(index, 1);
            
            if (cache.removeTimers.has(rowElement)) {
                clearTimeout(cache.removeTimers.get(rowElement));
                cache.removeTimers.delete(rowElement);
            }
            
            if (rowElement.parentNode) {
                rowElement.parentNode.removeChild(rowElement);
            }
            
            if (cache.displayedAthletes.length === 0) {
                ui.waitingState.style.display = 'block';
            }
        }

        // Po≈ÇƒÖczenie z Bridge przez WebSocket
        function connectToBridge() {
            try {
                const wsUrl = `ws://${config.bridge.ip}:${config.bridge.port}`;
                console.log(`Connecting to bridge: ${wsUrl}`);
                
                config.bridge.socket = new WebSocket(wsUrl);
                
                // Optymalizacja WebSocket - bez buforowania
                config.bridge.socket.binaryType = 'arraybuffer';
                
                config.bridge.socket.onopen = () => {
                    config.bridge.connected = true;
                    updateBridgeStatus();
                    showStatus('bridge-status-msg', 'Po≈ÇƒÖczono z Bridge', 'success');
                    console.log('Connected to bridge - REAL-TIME MODE');
                };
                
                config.bridge.socket.onmessage = (event) => {
                    // NATYCHMIASTOWE przetwarzanie - bez setTimeout, bez kolejki
                    const startTime = performance.now();
                    try {
                        const data = JSON.parse(event.data);
                        handleBridgeMessage(data);
                        const processingTime = performance.now() - startTime;
                        console.log(`Message processed in ${processingTime.toFixed(2)}ms`);
                    } catch (error) {
                        console.error('Error parsing bridge message:', error);
                    }
                };
                
                config.bridge.socket.onclose = () => {
                    config.bridge.connected = false;
                    updateBridgeStatus();
                    showStatus('bridge-status-msg', 'Roz≈ÇƒÖczono z Bridge', 'error');
                    console.log('Disconnected from bridge');
                    
                    setTimeout(() => {
                        if (!config.bridge.connected) {
                            connectToBridge();
                        }
                    }, 2000); // Szybsze ponowne po≈ÇƒÖczenie - 2 sekundy
                };
                
                config.bridge.socket.onerror = (error) => {
                    console.error('Bridge connection error:', error);
                    showStatus('bridge-status-msg', 'B≈ÇƒÖd po≈ÇƒÖczenia z Bridge', 'error');
                };
                
            } catch (error) {
                console.error('Error connecting to bridge:', error);
                showStatus('bridge-status-msg', `B≈ÇƒÖd po≈ÇƒÖczenia: ${error.message}`, 'error');
            }
        }

        function handleBridgeMessage(data) {
            const msgReceiveTime = performance.now();
            console.log(`[${msgReceiveTime.toFixed(2)}ms] Bridge message received:`, data);

            if (data.type === 'ccs_reading' && data.tag) {
                handleTagRead(data.tag, data.time, msgReceiveTime);
            } else if (data.type === 'winners_data' && data.winners) {
                handleWinnersData(data.winners, data.eventName);
            }
        }

        // Obs≈Çuga danych zwyciƒôzc√≥w otrzymanych z komputera
        function handleWinnersData(winners, eventName) {
            console.log(`Received winners data: ${winners.length} entries`);
            cache.winners = winners;

            // Aktualizacja statusu
            const statusHtml = `<span class="status-received">‚úÖ Odebrano dane zwyciƒôzc√≥w${eventName ? ` - ${eventName}` : ''} (${winners.length} pozycji)</span>`;
            ui.winnersStatus.innerHTML = statusHtml;

            // Wy≈õwietlenie zwyciƒôzc√≥w
            displayWinners(winners);

            // Automatyczne prze≈ÇƒÖczenie na zak≈Çadkƒô zwyciƒôzc√≥w (opcjonalnie)
            // switchTab('winners');
        }

        // Wy≈õwietlanie zwyciƒôzc√≥w
        function displayWinners(winners) {
            if (!winners || winners.length === 0) {
                ui.winnersContainer.innerHTML = `
                    <div class="winners-waiting-state">
                        <h3>üèÖ Brak danych zwyciƒôzc√≥w</h3>
                        <p>Oczekiwanie na dane z komputera...</p>
                    </div>
                `;
                return;
            }

            // Grupowanie wed≈Çug kategorii
            const categories = new Map();
            winners.forEach(winner => {
                const cat = winner.division || 'OPEN';
                if (!categories.has(cat)) {
                    categories.set(cat, []);
                }
                categories.get(cat).push(winner);
            });

            // Sortowanie kategorii
            let sortedCategories = Array.from(categories.entries());

            if (cache.winnersDisplayMode === 'alternating') {
                // Naprzemiennie: K, M, K16, M16, K20, M20, etc.
                sortedCategories = sortCategoriesAlternating(sortedCategories);
            } else {
                // Grupowane: wszystkie K, potem wszystkie M
                sortedCategories = sortCategoriesGrouped(sortedCategories);
            }

            // Generowanie HTML
            let html = '';
            sortedCategories.forEach(([category, categoryWinners]) => {
                const categoryClass = getCategoryClass(category);

                html += `<div class="winner-category">`;
                html += `<div class="winner-category-header ${categoryClass}">${category} (${categoryWinners.length})</div>`;
                html += `<div class="winners-table-header">
                    <div>Miejsce</div>
                    <div>Zawodnik</div>
                    <div>Miejscowo≈õƒá</div>
                    <div>Czas</div>
                    <div>Nr start.</div>
                </div>`;

                categoryWinners.forEach(winner => {
                    const rankClass = getRankClass(winner.rank);
                    // Usu≈Ñ cudzys≈Çowy z czasu
                    const cleanTime = (winner.time || '').replace(/"/g, '');

                    html += `
                        <div class="winner-row">
                            <div class="winner-rank ${rankClass}">${winner.rank}</div>
                            <div class="winner-info">
                                <div class="winner-name">${winner.name || ''}</div>
                            </div>
                            <div class="winner-hometown">${winner.hometown || ''}</div>
                            <div class="winner-time">${cleanTime}</div>
                            <div class="winner-bib">${winner.bib || ''}</div>
                        </div>
                    `;
                });

                html += `</div>`;
            });

            ui.winnersContainer.innerHTML = html;
        }

        // Sortowanie kategorii naprzemiennie (K, M, K16, M16, ...)
        function sortCategoriesAlternating(categories) {
            const open = [];
            const female = [];
            const male = [];
            const extra = [];

            categories.forEach(([cat, winners]) => {
                const upperCat = cat.toUpperCase();
                // Najpierw sprawd≈∫ czy to kategoria dodatkowa
                if (upperCat.includes('DODATKOWE') || upperCat.includes('DODATK')) {
                    extra.push([cat, winners]);
                } else if (upperCat === 'OPEN' || upperCat === 'OVERALL') {
                    open.push([cat, winners]);
                } else if (upperCat.startsWith('K') || upperCat.includes('KOBIET') || upperCat.includes('FEMALE') || upperCat.includes('WOMEN')) {
                    female.push([cat, winners]);
                } else if (upperCat.startsWith('M') || upperCat.includes('MƒòSKI') || upperCat.includes('MALE') || upperCat.includes('MEN')) {
                    male.push([cat, winners]);
                } else {
                    extra.push([cat, winners]);
                }
            });

            // Sortowanie K i M wed≈Çug numeru kategorii
            const sortByNumber = (a, b) => {
                const numA = parseInt(a[0].match(/\d+/)?.[0] || '0');
                const numB = parseInt(b[0].match(/\d+/)?.[0] || '0');
                return numA - numB;
            };

            female.sort(sortByNumber);
            male.sort(sortByNumber);

            // Przeplatanie K i M
            const result = [...open];
            const maxLen = Math.max(female.length, male.length);
            for (let i = 0; i < maxLen; i++) {
                if (female[i]) result.push(female[i]);
                if (male[i]) result.push(male[i]);
            }

            return [...result, ...extra];
        }

        // Sortowanie kategorii grupowane (wszystkie K, potem M)
        function sortCategoriesGrouped(categories) {
            const open = [];
            const female = [];
            const male = [];
            const extra = [];

            categories.forEach(([cat, winners]) => {
                const upperCat = cat.toUpperCase();
                // Najpierw sprawd≈∫ czy to kategoria dodatkowa
                if (upperCat.includes('DODATKOWE') || upperCat.includes('DODATK')) {
                    extra.push([cat, winners]);
                } else if (upperCat === 'OPEN' || upperCat === 'OVERALL') {
                    open.push([cat, winners]);
                } else if (upperCat.startsWith('K') || upperCat.includes('KOBIET') || upperCat.includes('FEMALE') || upperCat.includes('WOMEN')) {
                    female.push([cat, winners]);
                } else if (upperCat.startsWith('M') || upperCat.includes('MƒòSKI') || upperCat.includes('MALE') || upperCat.includes('MEN')) {
                    male.push([cat, winners]);
                } else {
                    extra.push([cat, winners]);
                }
            });

            const sortByNumber = (a, b) => {
                const numA = parseInt(a[0].match(/\d+/)?.[0] || '0');
                const numB = parseInt(b[0].match(/\d+/)?.[0] || '0');
                return numA - numB;
            };

            female.sort(sortByNumber);
            male.sort(sortByNumber);
            extra.sort((a, b) => a[0].localeCompare(b[0]));

            return [...open, ...female, ...male, ...extra];
        }

        // Pomocnicze funkcje do stylowania
        function getCategoryClass(category) {
            const upper = category.toUpperCase();
            // Najpierw sprawd≈∫ czy to kategoria dodatkowa
            if (upper.includes('DODATKOWE') || upper.includes('DODATK')) return 'extra';
            if (upper === 'OPEN' || upper === 'OVERALL') return 'open-category';
            if (upper.startsWith('K') || upper.includes('KOBIET') || upper.includes('FEMALE') || upper.includes('WOMEN')) return 'female';
            if (upper.startsWith('M') || upper.includes('MƒòSKI') || upper.includes('MALE') || upper.includes('MEN')) return 'male';
            return 'extra';
        }

        function getCategoryIcon(category) {
            const upper = category.toUpperCase();
            if (upper === 'OPEN' || upper === 'OVERALL') return 'üëë';
            if (upper.startsWith('K') || upper.includes('KOBIET') || upper.includes('FEMALE') || upper.includes('WOMEN')) return 'üë©';
            if (upper.startsWith('M') || upper.includes('MƒòSKI') || upper.includes('MALE') || upper.includes('MEN')) return 'üë®';
            return 'üèÜ';
        }

        function getRankClass(rank) {
            if (rank === 1 || rank === '1') return 'gold';
            if (rank === 2 || rank === '2') return 'silver';
            if (rank === 3 || rank === '3') return 'bronze';
            return '';
        }

        function getRankIcon(rank) {
            if (rank === 1 || rank === '1') return 'ü•á ';
            if (rank === 2 || rank === '2') return 'ü•à ';
            if (rank === 3 || rank === '3') return 'ü•â ';
            return '';
        }

        function handleTagRead(tag, time, receiveTime) {
            const startTime = performance.now();
            console.log(`[${startTime.toFixed(2)}ms] Tag read START: ${tag} at ${time}`);
            console.log(`  Delay from receive: ${(startTime - receiveTime).toFixed(2)}ms`);
            
            const athlete = findAthleteByTag(tag);
            
            if (athlete) {
                if (isAthleteBlocked(athlete.bib)) {
                    console.log(`Athlete ${athlete.bib} is blocked`);
                    return;
                }
                
                const beforeBlock = performance.now();
                addRecentRead(athlete, time);
                blockAthlete(athlete.bib);
                console.log(`  Blocking took: ${(performance.now() - beforeBlock).toFixed(2)}ms`);
                
                // Pobierz aktualny wynik z cache
                const beforeCache = performance.now();
                const result = cache.results.get(athlete.bib);
                console.log(`  Cache lookup took: ${(performance.now() - beforeCache).toFixed(2)}ms`);
                
                const beforeCreate = performance.now();
                const athleteRow = createAthleteRow(athlete, result);
                console.log(`  Row creation took: ${(performance.now() - beforeCreate).toFixed(2)}ms`);
                
                // NATYCHMIASTOWE wy≈õwietlenie - bez czekania na API
                const beforeAdd = performance.now();
                addAthleteRow(athleteRow);
                console.log(`  Row display took: ${(performance.now() - beforeAdd).toFixed(2)}ms`);
                
                cache.totalReads++;
                cache.uniqueAthletes.add(athlete.bib);
                
                const totalTime = performance.now() - startTime;
                console.log(`[${performance.now().toFixed(2)}ms] Tag read COMPLETE: Total time ${totalTime.toFixed(2)}ms`);
                console.log(`‚úÖ ZAWODNIK WY≈öWIETLONY NATYCHMIAST - API aktualizuje siƒô w tle przez auto-refresh`);
                
                // USUNIƒòTE: Nie robimy indywidualnego API request
                // API aktualizuje siƒô automatycznie co 30 sekund przez auto-refresh
                // To zapewnia MAKSYMALNƒÑ szybko≈õƒá wy≈õwietlania
                
            } else {
                console.log(`Athlete not found for tag: ${tag}`);
                showStatus('search-status', `Nie znaleziono zawodnika dla tagu: ${tag}`, 'warning');
            }
        }

        function findAthleteByTag(tag) {
            for (const [bib, athlete] of cache.athletes) {
                if (athlete.tag === tag || athlete.bib === tag) {
                    return athlete;
                }
            }
            return null;
        }

        function isAthleteBlocked(bib) {
            const blockEnd = cache.blockedAthletes.get(bib);
            if (blockEnd && new Date() < blockEnd) {
                return true;
            }
            
            if (blockEnd) {
                cache.blockedAthletes.delete(bib);
            }
            
            return false;
        }

        function blockAthlete(bib) {
            const blockEnd = new Date();
            blockEnd.setMinutes(blockEnd.getMinutes() + config.settings.blockTimeMinutes);
            cache.blockedAthletes.set(bib, blockEnd);
        }

        function addRecentRead(athlete, time) {
            const read = {
                ...athlete,
                readTime: time,
                timestamp: new Date()
            };
            
            cache.recentReads.unshift(read);
            
            if (cache.recentReads.length > 50) {
                cache.recentReads = cache.recentReads.slice(0, 50);
            }
        }

        function searchAthlete(query) {
            if (!query) return null;
            
            if (cache.athletes.has(query)) {
                return cache.athletes.get(query);
            }
            
            for (const [bib, athlete] of cache.athletes) {
                const fullName = `${athlete.firstName} ${athlete.lastName}`.toLowerCase();
                if (fullName.includes(query.toLowerCase())) {
                    return athlete;
                }
            }
            
            return null;
        }

        // Prze≈ÇƒÖczanie zak≈Çadek
        function switchTab(tabName) {
            ui.speakerContent.classList.remove('active');
            ui.resultsContent.classList.remove('active');
            ui.winnersContent.classList.remove('active');

            ui.speakerTab.classList.remove('active');
            ui.resultsTab.classList.remove('active');
            ui.winnersTab.classList.remove('active');

            if (tabName === 'speaker') {
                ui.speakerContent.classList.add('active');
                ui.speakerTab.classList.add('active');
            } else if (tabName === 'results') {
                ui.resultsContent.classList.add('active');
                ui.resultsTab.classList.add('active');
            } else if (tabName === 'winners') {
                ui.winnersContent.classList.add('active');
                ui.winnersTab.classList.add('active');
            }
        }

        // Aktualizacja status√≥w
        function updateBridgeStatus() {
            if (config.bridge.connected) {
                ui.bridgeIndicator.classList.add('connected');
                ui.bridgeStatus.textContent = `Bridge: Po≈ÇƒÖczony (${config.bridge.ip}:${config.bridge.port})`;
            } else {
                ui.bridgeIndicator.classList.remove('connected');
                ui.bridgeStatus.textContent = 'Bridge: Roz≈ÇƒÖczony';
            }
        }

        function updateApiStatus(connected = false) {
            if (connected) {
                ui.apiIndicator.classList.add('connected');
                ui.apiStatus.textContent = 'API: Po≈ÇƒÖczony';
            } else {
                ui.apiIndicator.classList.remove('connected');
                ui.apiStatus.textContent = 'API: Roz≈ÇƒÖczony';
            }
        }

        function updateEventInfo() {
            if (cache.eventInfo) {
                ui.eventInfo.textContent = `${cache.eventInfo.name} - ${cache.eventInfo.date}`;
            } else {
                ui.eventInfo.textContent = 'Brak wydarzenia';
            }
        }

        function updateAthleteCount() {
            ui.athleteCount.textContent = `Zawodnicy: ${cache.athletes.size}`;
            updateStatisticsBar();
        }

        // Obliczanie i wy≈õwietlanie statystyk zawodnik√≥w
        function updateStatisticsBar() {
            const statsContainer = document.getElementById('stats-container');
            if (!statsContainer) return;

            // Zbierz statystyki wed≈Çug dystans√≥w
            const stats = {};
            let totalStarted = 0;
            let totalFinished = 0;

            // Policz wystartowanych i uko≈Ñczonych z cache.results
            // Wystartowani = ci kt√≥rzy majƒÖ startTime (czas startu z chipa)
            //                LUB majƒÖ netTime (je≈õli kto≈õ jest na mecie, to na pewno wystartowa≈Ç - nawet bez czasu startu)
            // Uko≈Ñczeni = ci kt√≥rzy majƒÖ netTime (czas netto na mecie)
            cache.results.forEach(result => {
                const athlete = cache.athletes.get(result.bib);
                const distance = athlete?.distance || result.distance || 'Nieznany';

                if (!stats[distance]) {
                    stats[distance] = { started: 0, finished: 0, onCourse: 0 };
                }

                // Sprawd≈∫ czy ma czas startu
                const hasStartTime = result.startTime && result.startTime !== null;
                const hasNetTime = result.netTime && result.netTime !== '-' && result.netTime !== '';

                // Kto≈õ wystartowa≈Ç je≈õli ma czas startu LUB czas mety (je≈õli jest na mecie to na pewno wystartowa≈Ç)
                if (hasStartTime || hasNetTime) {
                    stats[distance].started++;
                    totalStarted++;
                }

                // Uko≈Ñczy≈Ç je≈õli ma netTime
                if (hasNetTime) {
                    stats[distance].finished++;
                    totalFinished++;
                }
            });

            // Oblicz na trasie dla ka≈ºdego dystansu
            for (const distance in stats) {
                stats[distance].onCourse = Math.max(0, stats[distance].started - stats[distance].finished);
            }

            const totalOnCourse = Math.max(0, totalStarted - totalFinished);

            // Buduj HTML
            let html = '';

            // Sortuj dystanse alfabetycznie
            const sortedDistances = Object.keys(stats).sort();

            if (sortedDistances.length === 0) {
                html = '<span style="color: #aaa;">Brak danych - pobierz zawodnik√≥w z API</span>';
            } else {
                // Dystanse w jednym wierszu
                html += '<div class="stats-distances-row">';
                sortedDistances.forEach(distance => {
                    const s = stats[distance];
                    html += `
                        <div class="stats-distance-group">
                            <span class="stats-distance-name">${distance}</span>
                            <div class="stats-item">
                                <span class="stats-label">Start:</span>
                                <span class="stats-value started">${s.started}</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">Meta:</span>
                                <span class="stats-value finished">${s.finished}</span>
                            </div>
                            <div class="stats-item">
                                <span class="stats-label">Trasa:</span>
                                <span class="stats-value on-course">${s.onCourse}</span>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';

                // Podsumowanie na dole
                html += `
                    <div class="stats-total">
                        RAZEM: ${totalStarted} start | ${totalFinished} meta | ${totalOnCourse} trasa
                    </div>
                `;
            }

            statsContainer.innerHTML = html;
        }

        // Aktualizacja zak≈Çadek dystans√≥w
        function updateDistanceTabs() {
            ui.distanceTabs.innerHTML = '';
            
            const allTab = document.createElement('div');
            allTab.className = 'distance-tab';
            if (!currentFilters.distance) allTab.classList.add('active');
            allTab.textContent = 'Wszystkie';
            allTab.addEventListener('click', () => {
                document.querySelectorAll('.distance-tab').forEach(t => t.classList.remove('active'));
                allTab.classList.add('active');
                currentFilters.distance = null;
                updateResultsTable();
            });
            ui.distanceTabs.appendChild(allTab);
            
            cache.distances.forEach(distance => {
                const tab = document.createElement('div');
                tab.className = 'distance-tab';
                if (currentFilters.distance === distance) tab.classList.add('active');
                tab.textContent = distance;
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.distance-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    currentFilters.distance = distance;
                    updateResultsTable();
                });
                ui.distanceTabs.appendChild(tab);
            });
        }

        // Aktualizacja zak≈Çadek kategorii
        function updateCategoryTabs() {
            ui.categoryTabs.innerHTML = '';
            
            const allTab = document.createElement('div');
            allTab.className = 'category-tab';
            if (!currentFilters.category) allTab.classList.add('active');
            allTab.textContent = 'Wszystkie';
            allTab.addEventListener('click', () => {
                document.querySelectorAll('.category-tab').forEach(t => t.classList.remove('active'));
                allTab.classList.add('active');
                currentFilters.category = null;
                updateResultsTable();
            });
            ui.categoryTabs.appendChild(allTab);
            
            cache.categories.forEach(category => {
                const tab = document.createElement('div');
                tab.className = 'category-tab';
                if (currentFilters.category === category) tab.classList.add('active');
                tab.textContent = category;
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.category-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    currentFilters.category = category;
                    updateResultsTable();
                });
                ui.categoryTabs.appendChild(tab);
            });
        }

        // Aktualizacja zak≈Çadek punkt√≥w kontrolnych
        function updateCheckpointTabs() {
            ui.checkpointTabs.innerHTML = '';
            
            const finishTab = document.createElement('div');
            finishTab.className = 'checkpoint-tab';
            if (!currentFilters.checkpoint) finishTab.classList.add('active');
            finishTab.textContent = 'Meta';
            finishTab.addEventListener('click', () => {
                document.querySelectorAll('.checkpoint-tab').forEach(t => t.classList.remove('active'));
                finishTab.classList.add('active');
                currentFilters.checkpoint = null;
                updateResultsTable();
                hideCheckpointInfo();
            });
            ui.checkpointTabs.appendChild(finishTab);
            
            cache.checkpoints.forEach(checkpointName => {
                const tab = document.createElement('div');
                tab.className = 'checkpoint-tab';
                if (currentFilters.checkpoint === checkpointName) tab.classList.add('active');
                
                const coursePoint = cache.courseData.get(checkpointName);
                let displayName;
                let distanceInfo;
                
                if (coursePoint && coursePoint.distance_km) {
                    displayName = `${coursePoint.distance_km} km`;
                    distanceInfo = coursePoint.distance_km;
                } else {
                    displayName = checkpointName;
                    distanceInfo = '?';
                }
                
                tab.textContent = displayName;
                
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.checkpoint-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    currentFilters.checkpoint = checkpointName;
                    updateResultsTable();
                    
                    showCheckpointInfo(checkpointName, distanceInfo);
                });
                ui.checkpointTabs.appendChild(tab);
            });
            
            console.log(`Updated checkpoint tabs: ${cache.checkpoints.length} checkpoints`);
        }

        function showCheckpointInfo(checkpointName, distanceInfo) {
            if (distanceInfo !== '?' && distanceInfo !== null && distanceInfo !== undefined) {
                const checkpointDistance = ui.checkpointInfo.querySelector('.checkpoint-distance');
                checkpointDistance.textContent = `${distanceInfo} km`;
                ui.checkpointInfo.classList.remove('hidden');
            } else {
                ui.checkpointInfo.classList.add('hidden');
            }
        }

        function hideCheckpointInfo() {
            ui.checkpointInfo.classList.add('hidden');
        }

        // Aktualizacja tabeli wynik√≥w
        function updateResultsTable() {
            ui.resultsTbody.innerHTML = '';
            
            const results = Array.from(cache.results.values());
            
            let filteredResults = results;
            if (currentFilters.distance) {
                filteredResults = filteredResults.filter(r => r.distance === currentFilters.distance);
            }
            if (currentFilters.category) {
                filteredResults = filteredResults.filter(r => r.category === currentFilters.category);
            }
            
            filteredResults.sort((a, b) => {
                const placeA = parseInt(a.overallPlace) || 9999;
                const placeB = parseInt(b.overallPlace) || 9999;
                return placeA - placeB;
            });
            
            filteredResults.forEach(result => {
                const row = document.createElement('tr');
                
                let displayTime = result.netTime;
                let displayPlace = result.overallPlace;
                
                if (currentFilters.checkpoint) {
                    const checkpoint = result.checkpoints.find(cp => cp.name === currentFilters.checkpoint);
                    if (checkpoint) {
                        displayTime = checkpoint.time;
                        displayPlace = checkpoint.place;
                    } else {
                        return;
                    }
                }
                
                const athlete = cache.athletes.get(result.bib);
                const city = athlete ? athlete.city : (result.city || '-');
                const club = athlete ? athlete.club : (result.club || '-');
                
                let checkpointsInfo = '-';
                if (result.checkpoints && result.checkpoints.length > 0) {
                    checkpointsInfo = result.checkpoints
                        .map(cp => {
                            const coursePoint = cache.courseData.get(cp.name);
                            
                            if (coursePoint && coursePoint.distance_km) {
                                return {
                                    ...cp,
                                    display_distance: coursePoint.distance_km,
                                    display_name: `${coursePoint.distance_km} km`
                                };
                            } else {
                                return {
                                    ...cp,
                                    display_distance: 999,
                                    display_name: cp.name
                                };
                            }
                        })
                        .sort((a, b) => {
                            if (a.display_distance === 999 && b.display_distance === 999) {
                                return a.display_name.localeCompare(b.display_name);
                            }
                            return a.display_distance - b.display_distance;
                        })
                        .map(cp => `${cp.display_name}: ${cp.time}`)
                        .join('<br>');
                }
                
                row.innerHTML = `
                    <td>${displayPlace || '-'}</td>
                    <td>${result.bib}</td>
                    <td>${result.firstName} ${result.lastName}</td>
                    <td>${result.category || '-'}</td>
                    <td>${city}</td>
                    <td>${club}</td>
                    <td><strong>${result.distance || '-'}</strong></td>
                    <td><strong>${displayTime || '-'}</strong></td>
                    <td style="font-size: 11px; line-height: 1.3;">${checkpointsInfo}</td>
                `;
                
                row.addEventListener('click', () => {
                    if (athlete) {
                        const athleteRow = createAthleteRow(athlete, result);
                        addAthleteRow(athleteRow);
                        switchTab('speaker');
                    }
                });
                
                ui.resultsTbody.appendChild(row);
            });
            
            if (ui.resultsTbody.children.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="9" style="text-align: center; color: #666; padding: 40px;">Brak wynik√≥w</td>';
                ui.resultsTbody.appendChild(row);
            }

            // Aktualizuj pasek statystyk po ka≈ºdej aktualizacji wynik√≥w
            updateStatisticsBar();
        }

        // Pe≈Çny ekran
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Zabezpieczenie przed zamkniƒôciem
        function setupExitProtection() {
            let isProtected = false;
            
            window.addEventListener('beforeunload', (e) => {
                if (isProtected) {
                    e.preventDefault();
                    e.returnValue = 'Czy na pewno chcesz opu≈õciƒá aplikacjƒô spikera?';
                    return e.returnValue;
                }
            });
            
            document.addEventListener('dataLoaded', () => {
                isProtected = true;
            });
        }

        // Pokazywanie statusu
        function showStatus(elementId, message, type = '') {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            element.textContent = message;
            element.className = `status-message ${type}`;
            
            if (message) {
                element.classList.remove('hidden');
                
                if (type === 'success') {
                    setTimeout(() => {
                        element.classList.add('hidden');
                    }, 5000);
                }
            } else {
                element.classList.add('hidden');
            }
        }

        // ≈Åadowanie konfiguracji
        function loadConfig() {
            ui.eventId.value = config.api.eventId;
            ui.bridgeIp.value = config.bridge.ip;
            ui.bridgePort.value = config.bridge.port;
            ui.blockTime.value = config.settings.blockTimeMinutes;
            ui.refreshInterval.value = config.settings.refreshInterval;
        }

        // Zapisywanie konfiguracji
        function saveConfig() {
            config.api.eventId = ui.eventId.value.trim();
            config.bridge.ip = ui.bridgeIp.value.trim();
            config.bridge.port = ui.bridgePort.value.trim();
            config.settings.blockTimeMinutes = parseInt(ui.blockTime.value);
            config.settings.refreshInterval = parseInt(ui.refreshInterval.value);
            
            localStorage.setItem('spiker-event-id', config.api.eventId);
            localStorage.setItem('bridge-ip', config.bridge.ip);
            localStorage.setItem('bridge-port', config.bridge.port);
            localStorage.setItem('block-time', config.settings.blockTimeMinutes);
            localStorage.setItem('refresh-interval', config.settings.refreshInterval);
            
            showStatus('data-status', 'Ustawienia zapisane', 'success');
        }

        // Event listenery
        ui.configToggle.addEventListener('click', () => {
            ui.configPanel.classList.toggle('open');
        });

        ui.speakerTab.addEventListener('click', () => {
            switchTab('speaker');
        });

        ui.resultsTab.addEventListener('click', () => {
            switchTab('results');
        });

        ui.winnersTab.addEventListener('click', () => {
            switchTab('winners');
        });

        ui.winnersModeAlternating.addEventListener('click', () => {
            ui.winnersModeAlternating.classList.add('active');
            ui.winnersModeGrouped.classList.remove('active');
            cache.winnersDisplayMode = 'alternating';
            if (cache.winners && cache.winners.length > 0) {
                displayWinners(cache.winners);
            }
        });

        ui.winnersModeGrouped.addEventListener('click', () => {
            ui.winnersModeGrouped.classList.add('active');
            ui.winnersModeAlternating.classList.remove('active');
            cache.winnersDisplayMode = 'grouped';
            if (cache.winners && cache.winners.length > 0) {
                displayWinners(cache.winners);
            }
        });

        ui.fullscreenToggle.addEventListener('click', () => {
            toggleFullscreen();
        });

        ui.searchBtn.addEventListener('click', () => {
            const query = ui.searchInput.value.trim();
            if (!query) return;
            
            const athlete = searchAthlete(query);
            if (athlete) {
                const result = cache.results.get(athlete.bib);
                const athleteRow = createAthleteRow(athlete, result);
                addAthleteRow(athleteRow);
                showStatus('search-status', 'Znaleziono zawodnika', 'success');
                ui.searchInput.value = '';
            } else {
                showStatus('search-status', 'Nie znaleziono zawodnika', 'error');
            }
        });

        ui.searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                ui.searchBtn.click();
            }
        });

        ui.connectBridge.addEventListener('click', () => {
            saveConfig();
            connectToBridge();
        });

        ui.loadData.addEventListener('click', async () => {
            const eventId = ui.eventId.value.trim();
            if (!eventId) {
                showStatus('data-status', 'Wprowad≈∫ ID wydarzenia', 'error');
                return;
            }
            
            config.api.eventId = eventId;
            localStorage.setItem('spiker-event-id', eventId);
            
            // Zatrzymaj poprzednie auto-od≈õwie≈ºanie
            stopAutoRefresh();
            
            showStatus('data-status', 'Pobieranie danych...', 'warning');
            
            try {
                updateApiStatus(false);
                
                showStatus('data-status', 'Pobieranie informacji o wydarzeniu...', 'warning');
                await fetchEventInfo();
                
                showStatus('data-status', 'Pobieranie punkt√≥w kontrolnych z course API...', 'warning');
                await fetchCourseData();
                
                showStatus('data-status', 'Pobieranie zawodnik√≥w...', 'warning');
                await fetchAllEntries();
                
                showStatus('data-status', 'Pobieranie wynik√≥w...', 'warning');
                await fetchResults('full'); // Pe≈Çne pobieranie przy inicjalizacji
                
                updateApiStatus(true);
                showStatus('data-status', 'Dane pobrane pomy≈õlnie - uruchomiono auto-od≈õwie≈ºanie', 'success');
                
                currentFilters.distance = null;
                currentFilters.checkpoint = null;
                currentFilters.category = null;
                
                updateResultsTable();
                
                // Uruchom automatyczne od≈õwie≈ºanie
                startAutoRefresh();
                
                document.dispatchEvent(new Event('dataLoaded'));
                
                console.log('=== LOADING SUMMARY ===');
                console.log(`Athletes: ${cache.athletes.size}`);
                console.log(`Results: ${cache.results.size}`);
                console.log(`Distances: ${cache.distances.length}`);
                console.log(`Checkpoints: ${cache.checkpoints.length}`);
                console.log(`Course timing points: ${cache.courseData.size}`);
                console.log('Auto-refresh: ENABLED');
                
            } catch (error) {
                updateApiStatus(false);
                showStatus('data-status', `B≈ÇƒÖd pobierania danych: ${error.message}`, 'error');
                console.error('Loading error:', error);
            }
        });

        ui.clearBlocked.addEventListener('click', () => {
            cache.blockedAthletes.clear();
            showStatus('data-status', 'Odblokowano wszystkich zawodnik√≥w', 'success');
        });

        ui.saveConfig.addEventListener('click', () => {
            saveConfig();
        });

        ui.manualRefresh.addEventListener('click', async () => {
            if (cache.results.size === 0) {
                showStatus('search-status', 'Najpierw pobierz dane wydarzenia', 'warning');
                return;
            }
            
            ui.manualRefresh.disabled = true;
            ui.manualRefresh.innerHTML = '<div class="loading"></div>Od≈õwie≈ºanie...';
            
            try {
                await fetchResults('quick'); // Szybkie od≈õwie≈ºanie
                updateResultsTable();
                showStatus('search-status', 'Wyniki od≈õwie≈ºone', 'success');
            } catch (error) {
                showStatus('search-status', `B≈ÇƒÖd od≈õwie≈ºania: ${error.message}`, 'error');
            } finally {
                ui.manualRefresh.disabled = false;
                ui.manualRefresh.innerHTML = 'üîÑ Od≈õwie≈º';
            }
        });

        // Inicjalizacja
        function init() {
            loadConfig();
            updateBridgeStatus();
            updateApiStatus();
            updateRefreshStatus(false);
            updateEventInfo();
            updateAthleteCount();
            
            setupExitProtection();
            
            // Cleanup przy zamkniƒôciu strony
            window.addEventListener('beforeunload', () => {
                stopAutoRefresh();
            });
            
            if (config.bridge.ip && config.bridge.port) {
                setTimeout(() => {
                    connectToBridge();
                }, 1000);
            }
            
            // Timer czyszczenia zablokowanych zawodnik√≥w
            setInterval(() => {
                const now = new Date();
                for (const [bib, blockEnd] of cache.blockedAthletes) {
                    if (now >= blockEnd) {
                        cache.blockedAthletes.delete(bib);
                    }
                }
            }, 60000);
            
            console.log('Spiker App initialized');
        }

        // Uruchomienie aplikacji
        init();
        
        // Obs≈Çuga klawiatury
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F11') {
                e.preventDefault();
                toggleFullscreen();
            }
            
            if (e.key === 'Escape') {
                ui.configPanel.classList.remove('open');
            }
            
            if (e.ctrlKey) {
                switch(e.key) {
                    case '1':
                        e.preventDefault();
                        switchTab('speaker');
                        break;
                    case '2':
                        e.preventDefault();
                        switchTab('results');
                        break;
                    case '3':
                        e.preventDefault();
                        switchTab('winners');
                        break;
                }
            }
        });
    </script>
</body>
</html>