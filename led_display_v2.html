<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YO&GO LED Display System</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #f5f5f5;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        body.display-mode {
            background: #000;
        }

        .container {
            max-width: 100vw;
            height: 100vh;
            margin: 0;
            background: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .container.display-mode {
            background: #000;
        }
        
        header {
            background: linear-gradient(135deg, #FF8C00, #FF7000);
            color: white;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        header h1 { font-size: 24px; }
        
        .mode-toggle {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }
        
        .mode-toggle:hover { background: rgba(255,255,255,0.3); }

        .screen {
            display: none !important;
            flex: 1;
        }

        /* DISPLAY SCREEN - Simple for athletes */
        #display-screen {
            padding: 20px;
            background: #fff;
            overflow-y: auto;
        }

        #display-screen.active {
            display: flex !important;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }

        /* === G≈Å√ìWNY ELEMENT: BIB INPUT === */
        .bib-main-panel {
            width: 100%;
            max-width: 900px;
            background: #f8f8f8;
            border-radius: 12px;
            border: 2px solid #ddd;
            padding: 30px 40px;
        }

        .bib-main-panel h2 {
            color: #FF8C00;
            font-size: 28px;
            margin-bottom: 20px;
            text-align: center;
        }

        #search-input {
            width: 100%;
            box-sizing: border-box;
            padding: 30px 20px;
            font-size: 72px;
            font-weight: bold;
            text-align: center;
            border: 3px solid #ddd;
            border-radius: 8px;
            margin-bottom: 16px;
            letter-spacing: 12px;
            color: #333;
            background: #fff;
        }

        #search-input:focus {
            border-color: #FF8C00;
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 140, 0, 0.2);
        }

        #search-btn {
            width: 100%;
            padding: 22px;
            font-size: 22px;
            font-weight: bold;
            letter-spacing: 4px;
            background: #FF8C00;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        #search-btn:hover { background: #FF7000; }

        .status-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 12px 15px;
            border-radius: 4px;
            margin-top: 12px;
            display: none;
        }

        .status-box.error {
            background: #ffe7e7;
            border-color: #f44336;
        }

        .status-box.success {
            background: #e7ffe7;
            border-color: #4CAF50;
        }

        /* === PASEK STATUSU (kompaktowy) === */
        .status-strip {
            width: 100%;
            max-width: 900px;
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .status-strip .connection-status {
            background: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 20px;
            padding: 6px 14px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* === MA≈ÅY PODGLƒÑD LED NA DOLE === */
        .led-preview {
            width: 100%;
            max-width: 900px;
            background: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 16px;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 20px;
        }

        .led-preview-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .led-preview-canvas-wrap {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #led-canvas {
            border: 2px solid #333;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 120px;
            height: 120px;
        }

        .led-preview-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .display-status {
            color: #FF3333;
            font-weight: bold;
            font-size: 13px;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: inline-block;
        }

        .unofficial-notice {
            color: #FF8C00;
            font-size: 14px;
            font-weight: bold;
            margin-top: 10px;
            margin-bottom: 5px;
            text-align: center;
            font-style: italic;
            padding: 5px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 3px;
        }

        .results-link {
            color: #333;
            font-size: 12px;
            text-align: center;
            margin-top: 5px;
            padding: 3px;
            font-weight: normal;
        }

        .results-link a {
            color: #FF8C00;
            text-decoration: none;
            font-weight: 600;
        }

        .results-link a:hover {
            text-decoration: underline;
        }
        
        .led-info {
            color: #888;
            font-size: 12px;
            margin-top: 15px;
        }
        
        /* ADMIN SCREEN */
        #admin-screen {
            background: #f5f5f5;
            padding: 30px;
            overflow-y: auto;
        }

        #admin-screen.active {
            display: block !important;
        }

        .admin-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .panel {
            background: #f8f8f8;
            padding: 25px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        
        .panel h2 {
            color: #FF8C00;
            margin-bottom: 20px;
            font-size: 18px;
            border-bottom: 2px solid #FF8C00;
            padding-bottom: 10px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }
        
        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        input[type="checkbox"] {
            margin-right: 8px;
        }
        
        button {
            background: #FF8C00;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }
        
        button:hover { background: #FF7000; }
        button.secondary { background: #6c757d; }
        button.secondary:hover { background: #5a6268; }
        
        .hidden { display: none !important; }
        
        .checkbox-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
            display: inline-block;
            margin-right: 8px;
        }
        
        .status-indicator.connected { background: #28a745; animation: pulse 2s infinite; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #f0f0f0;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        .btn-full {
            width: 100%;
            padding: 15px;
            font-size: 16px;
            margin-top: 15px;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #FF8C00;
            font-size: 18px;
        }

        .modal-content input[type="password"] {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            border: 2px solid #ddd;
            border-radius: 6px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üñ•Ô∏è YO&GO LED Display System</h1>
            <div style="display: flex; align-items: center; gap: 15px;">
                <label style="display: flex; align-items: center; gap: 8px; font-size: 13px; cursor: pointer; user-select: none;">
                    <input type="checkbox" id="lock-cursor-checkbox" style="width: 18px; height: 18px; cursor: pointer;">
                    <span>üîí Blokuj kursor</span>
                </label>
                <button class="mode-toggle" id="mode-toggle" style="font-size: 12px; padding: 8px 16px;">üëÅÔ∏è Wy≈õwietl</button>
            </div>
        </header>

        <!-- DISPLAY SCREEN (for athletes) -->
        <div class="screen" id="display-screen">

            <!-- G≈Å√ìWNY ELEMENT: BIB Input -->
            <div class="bib-main-panel">
                <h2>Wprowad≈∫ numer startowy</h2>
                <input type="text" id="search-input" placeholder="000" autofocus autocomplete="off">
                <button id="search-btn">ENTER ‚Üµ</button>
                <div id="search-status" class="status-box"></div>
            </div>

            <!-- PASEK STATUSU (kompaktowy) -->
            <div class="status-strip">
                <div class="connection-status">
                    <span class="status-indicator" id="api-indicator"></span>
                    <span id="api-status">API: nie po≈ÇƒÖczono</span>
                </div>
                <div class="connection-status">
                    <span class="status-indicator" id="rfid-indicator"></span>
                    <span id="rfid-status">RFID: nie aktywny</span>
                </div>
                <div class="connection-status">
                    <span class="status-indicator" id="led-indicator"></span>
                    <span id="led-status">LED: gotowy</span>
                </div>
            </div>

            <!-- MA≈ÅY PODGLƒÑD LED (na dole) -->
            <div class="led-preview">
                <div class="led-preview-canvas-wrap">
                    <div class="led-preview-label">PodglƒÖd LED</div>
                    <canvas id="led-canvas" width="240" height="240"></canvas>
                </div>
                <div class="led-preview-info">
                    <div class="display-status" id="display-status"></div>
                    <div class="unofficial-notice">Wyniki nieoficjalne</div>
                    <div class="results-link">wyniki <a href="https://www.yogoevents.pl" target="_blank">www.yogoevents.pl</a></div>
                </div>
            </div>

        </div>

        <!-- ADMIN SCREEN -->
        <div class="screen active" id="admin-screen">
            <div class="admin-grid">
                <!-- API Config -->
                <div class="panel">
                    <h2>‚öôÔ∏è Konfiguracja API</h2>
                    <div class="form-group">
                        <label>ID Wydarzenia:</label>
                        <input type="text" id="event-id" placeholder="np. 87968">
                    </div>
                    <button id="save-api-btn" class="btn-full">Zapisz i po≈ÇƒÖcz</button>
                    <button id="refresh-cache-btn" class="btn-full secondary">üîÑ Od≈õwie≈º dane z API</button>
                    <div id="api-save-status" class="status-box"></div>
                </div>

                <!-- Display Config -->
                <div class="panel">
                    <h2>üé® Wy≈õwietlanie</h2>
                    <label style="font-weight: bold; margin-bottom: 10px; display: block;">Informacje:</label>
                    <div class="checkbox-grid">
                        <div><input type="checkbox" id="show-location" checked><label for="show-location">Miejscowo≈õƒá</label></div>
                        <div><input type="checkbox" id="show-distance"><label for="show-distance">Dystans</label></div>
                        <div><input type="checkbox" id="show-club" checked><label for="show-club">Klub</label></div>
                    </div>

                    <label style="font-weight: bold; margin: 15px 0 10px 0; display: block;">Czasy:</label>
                    <div class="checkbox-grid">
                        <div><input type="checkbox" id="show-net-time" checked><label for="show-net-time">Czas netto</label></div>
                        <div><input type="checkbox" id="show-gun-time"><label for="show-gun-time">Czas brutto</label></div>
                    </div>

                    <label style="font-weight: bold; margin: 15px 0 10px 0; display: block;">Miejsca:</label>
                    <div class="checkbox-grid">
                        <div><input type="checkbox" id="show-overall" checked><label for="show-overall">OPEN</label></div>
                        <div><input type="checkbox" id="show-gender" checked><label for="show-gender">K/M</label></div>
                        <div><input type="checkbox" id="show-age" checked><label for="show-age">Kategoria wiekowa</label></div>
                        <div><input type="checkbox" id="show-custom" checked><label for="show-custom">Kategoria dodatkowa</label></div>
                    </div>

                    <label style="font-weight: bold; margin: 15px 0 5px 0; display: block;">Dodatkowy tekst (nad YO&GO Events):</label>
                    <input type="text" id="custom-footer-text" placeholder="wpisz tekst" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <p style="font-size: 11px; color: #888; margin: 3px 0 10px 0;">Zostaw puste aby wy≈õwietliƒá tylko YO&GO Events</p>

                    <button id="save-display-btn" class="btn-full">Zapisz ustawienia</button>
                </div>

                <!-- RFID Config -->
                <div class="panel">
                    <h2>üì° RFID Czytnik (Keyboard Mode)</h2>
                    <div class="connection-status">
                        <span class="status-indicator active" id="admin-rfid-indicator"></span>
                        <span id="admin-rfid-status">Gotowy: Pod≈ÇƒÖcz czytnik USB</span>
                    </div>
                    <div class="info-box" style="background: #f0f8ff; padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 4px solid #4CAF50;">
                        <strong>üìã Instrukcja:</strong><br>
                        1. Pod≈ÇƒÖcz czytnik USB RFID do komputera<br>
                        2. Kliknij w pole wyszukiwania na ekranie LED<br>
                        3. Zbli≈º chipujƒÖcƒÖ opaskƒô - wynik pojawi siƒô automatycznie<br>
                        <br>
                        <strong>‚úÖ Kompatybilno≈õƒá:</strong> Dzia≈Ça z wiƒôkszo≈õciƒÖ czytnik√≥w USB (tryb HID/klawiatura)
                    </div>

                    <div class="form-group">
                        <label>Ostatnio odczytany TAG:</label>
                        <input type="text" id="last-rfid-tag" readonly placeholder="Oczekiwanie na TAG..." style="background: #f5f5f5;">
                    </div>
                </div>

                <!-- LED Connection -->
                <div class="panel">
                    <h2>üñ•Ô∏è Po≈ÇƒÖczenie z tablicƒÖ LED</h2>
                    <div class="form-group">
                        <label>Typ po≈ÇƒÖczenia:</label>
                        <select id="led-connection-type">
                            <option value="none">Brak (tylko podglƒÖd)</option>
                            <option value="hdmi">HDMI (F11 fullscreen)</option>
                            <option value="ethernet">Ethernet / HTTP</option>
                        </select>
                    </div>
                    
                    <div id="ethernet-config" class="hidden">
                        <div class="form-group">
                            <label>Adres IP tablicy:</label>
                            <input type="text" id="led-ip" placeholder="192.168.1.100">
                        </div>
                        <div class="form-group">
                            <label>Port:</label>
                            <input type="number" id="led-port" value="80">
                        </div>
                    </div>
                    
                    <button id="save-led-btn" class="btn-full">Zapisz po≈ÇƒÖczenie</button>
                    <button id="test-led-btn" class="btn-full secondary">Test po≈ÇƒÖczenia</button>
                    <button id="open-led-window-btn" class="btn-full" style="background: #00AA00; margin-top: 15px;">üñ•Ô∏è Otw√≥rz okno LED (HDMI)</button>
                    <p style="font-size: 11px; color: #888; margin-top: 5px;">Otwiera osobne okno do wy≈õwietlenia na drugim monitorze (LED). Przesu≈Ñ na LED i naci≈õnij F11.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Password Modal -->
    <div id="password-modal" class="modal">
        <div class="modal-content">
            <h3>Wprowad≈∫ has≈Ço administratora</h3>
            <input type="password" id="admin-password-input" placeholder="Has≈Ço" autofocus>
            <div id="password-error" class="status-box"></div>
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button id="cancel-password-btn" class="btn-full secondary">Anuluj</button>
                <button id="submit-password-btn" class="btn-full">OK</button>
            </div>
        </div>
    </div>

    <script>
    /**
     * YO&GO Events LED Display System
     * System do wy≈õwietlania wynik√≥w na tablicy LED 240x240 px (96x96 cm, P4)
     * Wersja 2.0
     */
    document.addEventListener('DOMContentLoaded', function() {
        // =====================================
        // CONFIGURATION
        // =====================================
        const config = {
            api: {
                clientId: '727dae7f',
                userId: 'lukasz@yogoevents.pl',
                userPass: 'f2b2f3082a9d2ae5091eb5920bee538dc01bb413',
                baseUrl: 'https://api.chronotrack.com',
                eventId: localStorage.getItem('led-event-id') || ''
            },
            display: {
                showLocation: localStorage.getItem('led-show-location') !== 'false',
                showDistance: localStorage.getItem('led-show-distance') === 'true',
                showClub: localStorage.getItem('led-show-club') !== 'false',
                showNetTime: localStorage.getItem('led-show-net-time') !== 'false',
                showGunTime: localStorage.getItem('led-show-gun-time') === 'true',
                showOverall: localStorage.getItem('led-show-overall') !== 'false',
                showGender: localStorage.getItem('led-show-gender') !== 'false',
                showAge: localStorage.getItem('led-show-age') !== 'false',
                showCustom: localStorage.getItem('led-show-custom') !== 'false',
                customFooterText: localStorage.getItem('led-custom-footer-text') || ''
            },
            led: {
                connectionType: localStorage.getItem('led-connection-type') || 'none',
                ip: localStorage.getItem('led-ip') || '192.168.1.100',
                port: localStorage.getItem('led-port') || '80'
            },
            rfid: {
                connected: false  // Keyboard mode - always ready when initialized
            },
            refreshInterval: 90000  // 90 seconds
        };

        // =====================================
        // DATA CACHE
        // =====================================
        const cache = {
            athletes: {},          // Zawodnicy po BIB
            tags: {},              // TAG -> BIB mapping
            clubs: {},             // BIB -> Club mapping
            openResults: [],       // Wyniki OPEN
            sexResults: { M: [], F: [] },
            ageResults: {},
            customResults: {},
            eventInfo: null,
            lastUpdate: {
                open: null,
                sex: null,
                age: null,
                custom: null
            },
            persistentData: {
                divisionPlaces: {},  // Miejsca w kategoriach zapisane po BIB
                genderPlaces: {}     // Miejsca wed≈Çug p≈Çci zapisane po BIB
            }
        };

        // =====================================
        // UI ELEMENTS
        // =====================================
        const ui = {
            // Mode toggle
            modeToggle: document.getElementById('mode-toggle'),
            displayScreen: document.getElementById('display-screen'),
            adminScreen: document.getElementById('admin-screen'),

            // Display screen
            searchInput: document.getElementById('search-input'),
            searchBtn: document.getElementById('search-btn'),
            searchStatus: document.getElementById('search-status'),
            ledCanvas: document.getElementById('led-canvas'),
            displayStatus: document.getElementById('display-status'),
            lockCursorCheckbox: document.getElementById('lock-cursor-checkbox'),

            // Status indicators
            apiIndicator: document.getElementById('api-indicator'),
            apiStatus: document.getElementById('api-status'),
            rfidIndicator: document.getElementById('rfid-indicator'),
            rfidStatus: document.getElementById('rfid-status'),
            ledIndicator: document.getElementById('led-indicator'),
            ledStatus: document.getElementById('led-status'),

            // Admin screen - API Config
            eventIdInput: document.getElementById('event-id'),
            saveApiBtn: document.getElementById('save-api-btn'),
            refreshCacheBtn: document.getElementById('refresh-cache-btn'),
            apiSaveStatus: document.getElementById('api-save-status'),

            // Admin screen - Display Config
            showLocation: document.getElementById('show-location'),
            showDistance: document.getElementById('show-distance'),
            showClub: document.getElementById('show-club'),
            showNetTime: document.getElementById('show-net-time'),
            showGunTime: document.getElementById('show-gun-time'),
            showOverall: document.getElementById('show-overall'),
            showGender: document.getElementById('show-gender'),
            showAge: document.getElementById('show-age'),
            showCustom: document.getElementById('show-custom'),
            customFooterText: document.getElementById('custom-footer-text'),
            saveDisplayBtn: document.getElementById('save-display-btn'),

            // Admin screen - RFID
            adminRfidIndicator: document.getElementById('admin-rfid-indicator'),
            adminRfidStatus: document.getElementById('admin-rfid-status'),

            // Admin screen - LED Connection
            ledConnectionType: document.getElementById('led-connection-type'),
            ethernetConfig: document.getElementById('ethernet-config'),
            ledIp: document.getElementById('led-ip'),
            ledPort: document.getElementById('led-port'),
            saveLedBtn: document.getElementById('save-led-btn'),
            testLedBtn: document.getElementById('test-led-btn'),
            openLedWindowBtn: document.getElementById('open-led-window-btn'),

            // Password modal
            passwordModal: document.getElementById('password-modal'),
            adminPasswordInput: document.getElementById('admin-password-input'),
            passwordError: document.getElementById('password-error'),
            submitPasswordBtn: document.getElementById('submit-password-btn'),
            cancelPasswordBtn: document.getElementById('cancel-password-btn')
        };

        const ADMIN_PASSWORD = '72';
        let currentMode = 'admin';  // 'display' or 'admin'
        let refreshTimer = null;
        let selectedAthlete = null;
        let ledWindow = null;

        // =====================================
        // UTILITY FUNCTIONS
        // =====================================

        function showStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            if (!element) return;

            element.textContent = message;
            element.className = 'status-box ' + type;
            element.style.display = message ? 'block' : 'none';

            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    element.style.display = 'none';
                }, 5000);
            }
        }

        function updateIndicator(indicatorId, statusId, connected, message) {
            const indicator = document.getElementById(indicatorId);
            const status = document.getElementById(statusId);

            if (indicator) {
                indicator.className = 'status-indicator' + (connected ? ' connected' : '');
            }
            if (status) {
                status.textContent = message;
            }
        }

        function formatTime(timeString) {
            if (!timeString) return '-';

            if (timeString.includes(':')) {
                const timeParts = timeString.split(':');
                let hours = parseInt(timeParts[0]);
                let minutes = parseInt(timeParts[1]);
                let secondsPart = timeParts[2] ? timeParts[2].split('.') : ['0'];
                let seconds = parseInt(secondsPart[0]);
                let milliseconds = secondsPart[1] ? parseInt(secondsPart[1]) : 0;

                if (milliseconds > 0) seconds++;
                if (seconds >= 60) { minutes++; seconds -= 60; }
                if (minutes >= 60) { hours++; minutes -= 60; }

                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
            return timeString;
        }

        function formatEventDate(timestamp) {
            if (!timestamp) return '-';
            try {
                const date = new Date(parseInt(timestamp) * 1000);
                return `${String(date.getDate()).padStart(2, '0')}.${String(date.getMonth() + 1).padStart(2, '0')}.${date.getFullYear()}`;
            } catch (error) {
                return timestamp;
            }
        }

        // =====================================
        // CATEGORY SELECTION FUNCTIONS
        // =====================================

        function isSexBracket(bracketName) {
            if (!bracketName) return false;
            const sexBrackets = ['M', 'K', 'F', 'MALE', 'FEMALE', 'Mƒò≈ªCZY≈πNI', 'KOBIETY'];
            return sexBrackets.includes(bracketName.toUpperCase());
        }

        function isAgeBracket(bracketName) {
            if (!bracketName) return false;
            return /^[MKF][\d\-\+]+/.test(bracketName);
        }

        function selectBestCategory(athlete) {
            if (athlete.bracket_positions && typeof athlete.bracket_positions === 'object') {
                const brackets = athlete.bracket_positions;
                let ageCategory = null;
                let customCategory = null;
                let sexCategory = null;

                for (const [bracketName, position] of Object.entries(brackets)) {
                    if (!position || position <= 0) continue;

                    if (isAgeBracket(bracketName)) {
                        if (!ageCategory) ageCategory = { name: bracketName, position: position };
                    } else if (isSexBracket(bracketName)) {
                        if (!sexCategory) sexCategory = { name: bracketName, position: position };
                    } else {
                        if (!customCategory) customCategory = { name: bracketName, position: position };
                    }
                }

                if (ageCategory) return ageCategory;
                else if (customCategory) return customCategory;
                else if (sexCategory) return sexCategory;
            }
            return null;
        }

        // =====================================
        // API FUNCTIONS
        // =====================================

        function buildApiUrl(endpoint, params = {}) {
            const authParams = {
                format: 'json',
                client_id: config.api.clientId,
                user_id: config.api.userId,
                user_pass: config.api.userPass,
                ...params
            };

            const queryString = Object.entries(authParams)
                .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
                .join('&');

            return `${config.api.baseUrl}${endpoint}?${queryString}`;
        }

        async function makeApiRequest(endpoint, params = {}) {
            try {
                const url = buildApiUrl(endpoint, params);
                console.log(`API Request: ${url}`);

                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);
                }

                return await response.json();
            } catch (error) {
                console.error(`API Request Error: ${error.message}`);
                throw error;
            }
        }

        async function fetchEventInfo() {
            try {
                const response = await makeApiRequest(`/api/event/${config.api.eventId}`);
                if (response && response.event) {
                    const eventData = response.event;
                    cache.eventInfo = {
                        event_id: eventData.event_id,
                        event_name: eventData.event_name,
                        event_date: formatEventDate(eventData.event_start_time),
                        location_city: eventData.location_city || '',
                        location_country: eventData.location_country || ''
                    };
                    return cache.eventInfo;
                }
                throw new Error('Invalid event data');
            } catch (error) {
                console.error(`Fetch Event Info Error: ${error.message}`);
                throw error;
            }
        }

        async function fetchAllResultPages(endpoint, params, maxPages = 10) {
            let page = 1;
            let allResults = [];
            let hasMorePages = true;

            while (hasMorePages && page <= maxPages) {
                try {
                    const pageParams = { ...params, page };
                    const response = await makeApiRequest(endpoint, pageParams);

                    if (response && response.event_results && response.event_results.length > 0) {
                        allResults = allResults.concat(response.event_results);

                        if (response.page_count && response.page) {
                            hasMorePages = parseInt(response.page) < parseInt(response.page_count);
                        } else if (response.event_results.length < params.size) {
                            hasMorePages = false;
                        }
                        page++;
                    } else {
                        hasMorePages = false;
                    }
                } catch (error) {
                    console.error(`Page ${page} error: ${error.message}`);
                    hasMorePages = false;
                }
            }

            return allResults;
        }

        function mapAthleteData(result) {
            const mapped = {
                entry_bib: result.results_bib,
                athlete_first_name: result.results_first_name,
                athlete_last_name: result.results_last_name,
                athlete_sex: result.results_sex,
                entry_race_age: result.results_age,
                bracket_name: result.results_primary_bracket_name,
                race_distance: result.results_race_name,
                net_time: result.results_time,
                gun_time: result.results_gun_time,
                overall_place: result.results_rank,
                gender_place: result.results_rank_in_bracket || result.results_rank || '',
                division_place: result.results_rank_in_bracket || result.results_bracket_rank || result.results_rank || '',
                pace: result.results_pace,
                formatted_net_time: formatTime(result.results_time),
                formatted_gun_time: formatTime(result.results_gun_time)
            };

            // Parsuj bracket_positions je≈õli istnieje
            if (result.bracket_positions) {
                if (typeof result.bracket_positions === 'string') {
                    try {
                        mapped.bracket_positions = JSON.parse(result.bracket_positions);
                    } catch (e) {
                        console.warn(`Failed to parse bracket_positions for BIB ${result.results_bib}:`, e);
                        mapped.bracket_positions = result.bracket_positions;
                    }
                } else {
                    mapped.bracket_positions = result.bracket_positions;
                }

                // Wybierz najlepszƒÖ kategoriƒô wed≈Çug priorytetu
                const bestCategory = selectBestCategory(mapped);
                if (bestCategory) {
                    mapped.bracket_name = bestCategory.name;
                    mapped.division_place = bestCategory.position;
                }
            }

            // Add club from cache if available
            if (cache.clubs && cache.clubs[mapped.entry_bib]) {
                mapped.club = cache.clubs[mapped.entry_bib];
            }

            return mapped;
        }

        async function refreshOpenResults() {
            try {
                const params = {
                    size: 100,
                    include_all_fields: '1'
                };
                console.log("Fetching OPEN results...");

                const allResults = await fetchAllResultPages(`/api/event/${config.api.eventId}/results`, params);

                if (allResults.length > 0) {
                    const mappedResults = allResults.map(mapAthleteData);

                    // TYLKO cache.openResults - NIE mieszamy w cache.athletes!
                    cache.openResults = mappedResults;
                    cache.lastUpdate.open = new Date();

                    console.log(`OPEN results updated: ${mappedResults.length} athletes`);
                    return mappedResults;
                }
                return [];
            } catch (error) {
                console.error(`Refresh OPEN error: ${error.message}`);
                return [];
            }
        }

        async function refreshSexResults() {
            try {
                const sexTypes = ['M', 'F'];
                const results = { M: [], F: [] };

                for (const sexType of sexTypes) {
                    const params = {
                        size: 100,
                        bracket: 'sex',
                        sex: sexType
                    };
                    console.log(`Fetching ${sexType} results...`);

                    const genderResults = await fetchAllResultPages(`/api/event/${config.api.eventId}/results`, params);

                    if (genderResults.length > 0) {
                        const mappedResults = genderResults.map(result => {
                            const mapped = {
                                entry_bib: result.results_bib,
                                athlete_first_name: result.results_first_name,
                                athlete_last_name: result.results_last_name,
                                athlete_sex: result.results_sex,
                                entry_race_age: result.results_age,
                                bracket_name: result.results_primary_bracket_name,
                                race_distance: result.results_race_name,
                                net_time: result.results_time,
                                gun_time: result.results_gun_time,
                                overall_place: result.results_rank,
                                gender_place: result.results_rank_in_bracket || result.results_bracket_rank || result.results_rank,
                                pace: result.results_pace,
                                formatted_net_time: formatTime(result.results_time),
                                formatted_gun_time: formatTime(result.results_gun_time)
                            };

                            if (cache.clubs && cache.clubs[mapped.entry_bib]) {
                                mapped.club = cache.clubs[mapped.entry_bib];
                            }

                            return mapped;
                        });

                        results[sexType] = mappedResults;
                    }
                }

                // TYLKO cache.sexResults - NIE mieszamy w cache.athletes!
                cache.sexResults = results;
                cache.lastUpdate.sex = new Date();
                console.log(`SEX results updated: M=${results.M.length}, F=${results.F.length}`);
                return results;
            } catch (error) {
                console.error(`Refresh SEX error: ${error.message}`);
                return { M: [], F: [] };
            }
        }

        async function refreshAgeResults() {
            try {
                const params = {
                    size: 100,
                    bracket: 'age'
                };
                console.log("Fetching AGE results...");

                const allResults = await fetchAllResultPages(`/api/event/${config.api.eventId}/results`, params);

                if (allResults.length > 0) {
                    const ageCategories = {};

                    const mappedResults = allResults.map(result => {
                        const mapped = {
                            entry_bib: result.results_bib,
                            athlete_first_name: result.results_first_name,
                            athlete_last_name: result.results_last_name,
                            athlete_sex: result.results_sex,
                            entry_race_age: result.results_age,
                            bracket_name: result.results_primary_bracket_name,
                            race_distance: result.results_race_name,
                            net_time: result.results_time,
                            gun_time: result.results_gun_time,
                            overall_place: result.results_rank,
                            division_place: result.results_rank_in_bracket || result.results_bracket_rank || result.results_rank,
                            pace: result.results_pace,
                            formatted_net_time: formatTime(result.results_time),
                            formatted_gun_time: formatTime(result.results_gun_time)
                        };

                        if (cache.clubs && cache.clubs[mapped.entry_bib]) {
                            mapped.club = cache.clubs[mapped.entry_bib];
                        }

                        return mapped;
                    });

                    // Grupuj wed≈Çug kategorii wiekowej
                    mappedResults.forEach(athlete => {
                        if (athlete.bracket_name) {
                            if (!ageCategories[athlete.bracket_name]) {
                                ageCategories[athlete.bracket_name] = [];
                            }
                            ageCategories[athlete.bracket_name].push(athlete);
                        }
                    });

                    // TYLKO cache.ageResults - NIE mieszamy w cache.athletes!
                    cache.ageResults = ageCategories;
                    cache.lastUpdate.age = new Date();
                    console.log(`AGE results updated: ${Object.keys(ageCategories).length} categories`);
                    return ageCategories;
                }
                return {};
            } catch (error) {
                console.error(`Refresh AGE error: ${error.message}`);
                return {};
            }
        }

        async function refreshCustomResults() {
            try {
                const customCategories = new Set();

                cache.openResults.forEach(athlete => {
                    if (athlete.bracket_name && !isAgeBracket(athlete.bracket_name) && !isSexBracket(athlete.bracket_name)) {
                        customCategories.add(athlete.bracket_name);
                    }
                });

                if (customCategories.size === 0) {
                    console.log("No custom categories found");
                    return {};
                }

                console.log(`Found ${customCategories.size} custom categories:`, Array.from(customCategories));
                const allCustomResults = {};

                for (const categoryName of customCategories) {
                    const params = {
                        size: 100,
                        bracket: categoryName,
                        include_all_fields: '1'
                    };

                    console.log(`Fetching ${categoryName} results...`);
                    const categoryResults = await fetchAllResultPages(`/api/event/${config.api.eventId}/results`, params);

                    if (categoryResults.length > 0) {
                        const mappedResults = categoryResults.map(result => {
                            const mapped = {
                                entry_bib: result.results_bib,
                                athlete_first_name: result.results_first_name,
                                athlete_last_name: result.results_last_name,
                                athlete_sex: result.results_sex,
                                entry_race_age: result.results_age,
                                bracket_name: result.results_primary_bracket_name,
                                race_distance: result.results_race_name,
                                net_time: result.results_time,
                                gun_time: result.results_gun_time,
                                overall_place: result.results_rank,
                                division_place: result.results_rank_in_bracket || result.results_bracket_rank || result.results_rank,
                                pace: result.results_pace,
                                formatted_net_time: formatTime(result.results_time),
                                formatted_gun_time: formatTime(result.results_gun_time)
                            };

                            if (cache.clubs && cache.clubs[mapped.entry_bib]) {
                                mapped.club = cache.clubs[mapped.entry_bib];
                            }

                            return mapped;
                        });

                        // TYLKO cache.customResults - NIE mieszamy w cache.athletes!
                        allCustomResults[categoryName] = mappedResults;

                        console.log(`Category ${categoryName}: ${mappedResults.length} athletes`);
                    }
                }

                cache.customResults = allCustomResults;
                cache.lastUpdate.custom = new Date();
                console.log(`CUSTOM results updated: ${Object.keys(allCustomResults).length} categories`);
                return allCustomResults;
            } catch (error) {
                console.error(`Refresh CUSTOM error: ${error.message}`);
                return {};
            }
        }

        async function fetchTags() {
            try {
                console.log("Fetching RFID tags from entries API...");

                const tagMapping = {};
                let page = 1;
                let hasMorePages = true;

                while (hasMorePages) {
                    const params = {
                        page: page,
                        size: 50,
                        include_test_entries: 'true',
                        elide_json: 'false'
                    };

                    const response = await makeApiRequest(`/api/event/${config.api.eventId}/entry`, params);

                    if (response && (response.event_entry || response.entries)) {
                        const entries = response.event_entry || response.entries || [];

                        if (entries.length > 0) {
                            entries.forEach(entry => {
                                const bib = entry.entry_bib;
                                const tag = entry.entry_rfid_tag || entry.rfid_tag;

                                if (bib && tag) {
                                    tagMapping[tag] = bib;
                                }
                            });

                            // Check pagination
                            if (response.page && response.page_count) {
                                hasMorePages = parseInt(response.page) < parseInt(response.page_count);
                            } else if (entries.length >= 50) {
                                hasMorePages = true;
                            } else {
                                hasMorePages = false;
                            }

                            page++;
                        } else {
                            hasMorePages = false;
                        }
                    } else {
                        hasMorePages = false;
                    }
                }

                cache.tags = tagMapping;
                console.log(`Loaded ${Object.keys(tagMapping).length} RFID tag mappings`);
                return tagMapping;
            } catch (error) {
                console.error(`Fetch RFID tags error: ${error.message}`);
                return {};
            }
        }

        async function fetchCustomQuestions() {
            try {
                console.log("Fetching club data from entries API...");

                const allEntries = {};
                let page = 1;
                let hasMorePages = true;

                while (hasMorePages) {
                    const params = {
                        page: page,
                        size: 50,
                        include_test_entries: 'true',
                        elide_json: 'false',
                        contact_details: 'true',
                        include_all_fields: 'true',
                        need_athlete_birthdate: 'true'
                    };

                    console.log(`Fetching entries page ${page}...`);
                    const response = await makeApiRequest(`/api/event/${config.api.eventId}/entry`, params);

                    if (response && (response.event_entry || response.entries)) {
                        const entries = response.event_entry || response.entries || [];

                        if (entries.length > 0) {
                            console.log(`Page ${page}: found ${entries.length} entries`);

                            entries.forEach(entry => {
                                const bib = entry.entry_bib;
                                if (!bib) return;

                                // Extract club from various possible fields (ignore "Tak" responses)
                                let club = '';

                                // 1. Check direct club field
                                if (entry.club && entry.club !== 'Tak') {
                                    club = entry.club;
                                }
                                // 2. Check athlete_club field
                                else if (entry.athlete_club && entry.athlete_club !== 'Tak') {
                                    club = entry.athlete_club;
                                }
                                // 3. Check custom_element fields
                                else {
                                    for (const [key, value] of Object.entries(entry)) {
                                        if (key.startsWith('custom_element') && value && value !== 'Tak') {
                                            club = value;
                                            break;  // Take first non-"Tak" custom field
                                        }
                                    }
                                }

                                if (club) {
                                    allEntries[bib] = club.toString().trim();
                                }
                            });

                            // Check pagination
                            if (response.page && response.page_count) {
                                hasMorePages = parseInt(response.page) < parseInt(response.page_count);
                            } else if (entries.length >= 50) {
                                hasMorePages = true;
                            } else {
                                hasMorePages = false;
                            }

                            page++;
                        } else {
                            hasMorePages = false;
                        }
                    } else {
                        console.log('No entries on this page');
                        hasMorePages = false;
                    }
                }

                cache.clubs = allEntries;
                console.log(`Loaded ${Object.keys(allEntries).length} club mappings`);
                return allEntries;
            } catch (error) {
                console.error(`Fetch club data error: ${error.message}`);
                return {};
            }
        }

        async function refreshAllData() {
            try {
                updateIndicator('api-indicator', 'api-status', false, 'API: Od≈õwie≈ºanie...');

                // Wyczy≈õƒá cache zawodnik√≥w ≈ºeby za≈Çadowaƒá ≈õwie≈ºe dane z bracket_positions
                cache.athletes = {};
                console.log('Cleared athletes cache for fresh data reload');

                await fetchEventInfo();
                await refreshOpenResults();

                await Promise.all([
                    refreshSexResults(),
                    refreshAgeResults(),
                    refreshCustomResults(),
                    fetchTags(),
                    fetchCustomQuestions()
                ]);

                // Update cached athletes with clubs
                if (cache.clubs) {
                    Object.keys(cache.athletes).forEach(bib => {
                        if (cache.clubs[bib]) {
                            cache.athletes[bib].club = cache.clubs[bib];
                        }
                    });
                    console.log('Updated cached athletes with clubs');
                }

                updateIndicator('api-indicator', 'api-status', true, `API: ${cache.eventInfo.event_name}`);
                return true;
            } catch (error) {
                console.error(`Refresh all data error: ${error.message}`);
                updateIndicator('api-indicator', 'api-status', false, 'API: B≈ÇƒÖd po≈ÇƒÖczenia');
                return false;
            }
        }

        function setupRefreshTimer() {
            if (refreshTimer) clearInterval(refreshTimer);

            // Co 30 sekund od≈õwie≈ºaj TYLKO wyniki (czasy i miejsca w kategoriach)
            // Klub i event info siƒô nie zmienia - pobieramy tylko raz na starcie
            refreshTimer = setInterval(async () => {
                console.log('Auto-refresh: Updating results (times and places)...');
                await refreshOpenResults();
                await refreshSexResults('M');
                await refreshSexResults('F');
                await refreshAgeResults();
                await refreshCustomResults();
            }, 30000); // 30 seconds
        }

        /**
         * Pr√≥buje pobraƒá dane o miejscu zawodnika w kategorii (wiekowej, dodatkowej, p≈Çci)
         * WZOROWANE NA drukarka_wynikowv2.html - DZIA≈ÅAJƒÑCY PROGRAM!
         */
        async function getAthleteAgeGroupResult(athlete) {
            if (!athlete || !athlete.bracket_name || !athlete.entry_bib) return;

            try {
                // Sprawd≈∫ najpierw w cache ageResults
                if (cache.ageResults && cache.ageResults[athlete.bracket_name]) {
                    const matchingAthlete = cache.ageResults[athlete.bracket_name].find(
                        a => a.entry_bib === athlete.entry_bib
                    );

                    if (matchingAthlete && matchingAthlete.division_place) {
                        athlete.division_place = matchingAthlete.division_place;
                        console.log(`Znaleziono miejsce w kategorii w cache (age): ${athlete.entry_bib}, miejsce: ${athlete.division_place}`);
                        return;
                    }
                }

                // Sprawd≈∫ w cache customResults
                if (cache.customResults && cache.customResults[athlete.bracket_name]) {
                    const matchingAthlete = cache.customResults[athlete.bracket_name].find(
                        a => a.entry_bib === athlete.entry_bib
                    );

                    if (matchingAthlete && matchingAthlete.division_place) {
                        athlete.division_place = matchingAthlete.division_place;
                        console.log(`Znaleziono miejsce w kategorii w cache (custom): ${athlete.entry_bib}, miejsce: ${athlete.division_place}`);
                        return;
                    }
                }

                // Wykryj typ kategorii i u≈ºyj odpowiedniego parametru bracket
                let bracketType;
                if (isAgeBracket(athlete.bracket_name)) {
                    bracketType = 'age';
                } else if (isSexBracket(athlete.bracket_name)) {
                    bracketType = 'sex';
                } else {
                    // Dla kategorii dodatkowych (custom) u≈ºyj nazwy kategorii jako bracket
                    bracketType = athlete.bracket_name;
                }

                // Je≈õli nie ma w cache, spr√≥buj pobraƒá bezpo≈õrednio z API
                const params = {
                    bracket: bracketType,
                    bib: athlete.entry_bib
                };

                console.log(`Pobieranie miejsca w kategorii dla zawodnika ${athlete.entry_bib} z kategorii ${athlete.bracket_name} (typ: ${bracketType})`);
                const response = await makeApiRequest(`/api/event/${config.api.eventId}/results`, params);

                if (response && response.event_results && response.event_results.length > 0) {
                    const result = response.event_results[0];
                    console.log("Otrzymane dane kategorii z API:", result);

                    if (result.results_rank_in_bracket) {
                        athlete.division_place = result.results_rank_in_bracket;
                        console.log(`Zaktualizowano miejsce w kategorii: ${athlete.division_place}`);
                    } else if (result.results_bracket_rank) {
                        athlete.division_place = result.results_bracket_rank;
                        console.log(`Zaktualizowano miejsce w kategorii (bracket_rank): ${athlete.division_place}`);
                    } else if (result.results_division_rank) {
                        athlete.division_place = result.results_division_rank;
                        console.log(`Zaktualizowano miejsce w kategorii (division_rank): ${athlete.division_place}`);
                    }

                    // Aktualizuj r√≥wnie≈º cache
                    if (athlete.division_place && cache.athletes[athlete.entry_bib]) {
                        cache.athletes[athlete.entry_bib].division_place = athlete.division_place;
                    }
                } else {
                    console.log(`Brak wynik√≥w kategorii dla zawodnika ${athlete.entry_bib}`);
                }
            } catch (error) {
                console.error(`B≈ÇƒÖd pobierania miejsca w kategorii: ${error.message}`);
            }
        }

        async function findAthleteByBib(bib) {
            console.log(`Finding athlete BIB: ${bib}`);

            // KROK 1: Szukaj w cache.openResults (czasy, overall_place)
            let athlete = cache.openResults.find(a => a.entry_bib === bib || String(a.entry_bib) === String(bib));

            if (!athlete) {
                // Nie ma w cache - pobierz z API
                console.log(`BIB ${bib} nie ma w cache.openResults, pobieranie z API...`);
                try {
                    const response = await makeApiRequest(`/api/event/${config.api.eventId}/results`, { bib });
                    if (response && response.event_results && response.event_results.length > 0) {
                        const result = response.event_results.find(r =>
                            r.results_bib === bib || String(r.results_bib) === String(bib)
                        );
                        if (result) {
                            athlete = mapAthleteData(result);
                        }
                    }
                } catch (error) {
                    console.error(`B≈ÇƒÖd API dla BIB ${bib}:`, error);
                    return null;
                }
            }

            if (!athlete) {
                console.log(`BIB ${bib} nie znaleziony`);
                return null;
            }

            // Mamy podstawowe dane - teraz zbieramy miejsca w kategoriach
            const finalAthlete = { ...athlete };

            // KROK 2: Pobierz division_place z odpowiedniego cache
            if (finalAthlete.bracket_name) {
                if (isAgeBracket(finalAthlete.bracket_name)) {
                    // Kategoria wiekowa (M30, K40, etc.)
                    const ageCategory = cache.ageResults[finalAthlete.bracket_name];
                    if (ageCategory) {
                        const athleteInAge = ageCategory.find(a => a.entry_bib === bib || String(a.entry_bib) === String(bib));
                        if (athleteInAge && athleteInAge.division_place) {
                            finalAthlete.division_place = athleteInAge.division_place;
                            console.log(`‚úÖ Division place z cache.ageResults[${finalAthlete.bracket_name}]: ${finalAthlete.division_place}`);
                        }
                    } else {
                        // Brak w cache - wywo≈Çaj getAthleteAgeGroupResult
                        console.log(`Kategoria ${finalAthlete.bracket_name} nie w cache.ageResults, wywo≈Çujƒô getAthleteAgeGroupResult...`);
                        await getAthleteAgeGroupResult(finalAthlete);
                    }
                } else if (!isSexBracket(finalAthlete.bracket_name)) {
                    // Kategoria custom (WOJSKO, POLICJA, Konin-M, etc.)
                    const customCategory = cache.customResults[finalAthlete.bracket_name];
                    if (customCategory) {
                        const athleteInCustom = customCategory.find(a => a.entry_bib === bib || String(a.entry_bib) === String(bib));
                        if (athleteInCustom && athleteInCustom.division_place) {
                            finalAthlete.division_place = athleteInCustom.division_place;
                            console.log(`‚úÖ Division place z cache.customResults[${finalAthlete.bracket_name}]: ${finalAthlete.division_place}`);
                        }
                    } else {
                        // Brak w cache - wywo≈Çaj getAthleteAgeGroupResult (obs≈Çuguje te≈º custom)
                        console.log(`Kategoria custom ${finalAthlete.bracket_name} nie w cache.customResults, wywo≈Çujƒô getAthleteAgeGroupResult...`);
                        await getAthleteAgeGroupResult(finalAthlete);
                    }
                }
            }

            // KROK 3: Pobierz gender_place z cache.sexResults
            if (finalAthlete.athlete_sex && (finalAthlete.athlete_sex === 'M' || finalAthlete.athlete_sex === 'F')) {
                const sexResults = cache.sexResults[finalAthlete.athlete_sex];
                if (sexResults) {
                    const athleteInSex = sexResults.find(a => a.entry_bib === bib || String(a.entry_bib) === String(bib));
                    if (athleteInSex && athleteInSex.gender_place) {
                        finalAthlete.gender_place = athleteInSex.gender_place;
                        console.log(`‚úÖ Gender place z cache.sexResults[${finalAthlete.athlete_sex}]: ${finalAthlete.gender_place}`);
                    }
                }
            }

            // KROK 4: Pobierz klub - je≈õli nie ma w cache.clubs, zapytaj API bezpo≈õrednio
            // (fetchCustomQuestions() jest wolne bo pobiera wszystkich - nie czekamy na nie)
            if (cache.clubs && cache.clubs[bib]) {
                finalAthlete.club = cache.clubs[bib];
                console.log(`‚úÖ Klub z cache.clubs: ${finalAthlete.club}`);
            } else {
                // cache.clubs jeszcze nie gotowy - pobierz bezpo≈õrednio dla tego BIBu
                try {
                    const entryResponse = await makeApiRequest(`/api/event/${config.api.eventId}/entry`, {
                        bib,
                        include_all_fields: 'true',
                        elide_json: 'false'
                    });
                    const entries = entryResponse?.event_entry || entryResponse?.entries || [];
                    const entry = entries.find(e => e.entry_bib === bib || String(e.entry_bib) === String(bib));
                    if (entry) {
                        let club = '';
                        if (entry.club && entry.club !== 'Tak') club = entry.club;
                        else if (entry.athlete_club && entry.athlete_club !== 'Tak') club = entry.athlete_club;
                        else {
                            for (const [key, value] of Object.entries(entry)) {
                                if (key.startsWith('custom_element') && value && value !== 'Tak') {
                                    club = value;
                                    break;
                                }
                            }
                        }
                        if (club) {
                            finalAthlete.club = club.toString().trim();
                            // Zapisz do cache na przysz≈Ço≈õƒá
                            if (!cache.clubs) cache.clubs = {};
                            cache.clubs[bib] = finalAthlete.club;
                            console.log(`‚úÖ Klub z bezpo≈õredniego API: ${finalAthlete.club}`);
                        }
                    }
                } catch (e) {
                    console.warn(`Nie uda≈Ço siƒô pobraƒá klubu dla BIB ${bib}:`, e);
                }
            }

            console.log(`Final athlete data:`, {
                bib: finalAthlete.entry_bib,
                overall_place: finalAthlete.overall_place,
                bracket_name: finalAthlete.bracket_name,
                division_place: finalAthlete.division_place,
                gender_place: finalAthlete.gender_place,
                club: finalAthlete.club
            });

            return finalAthlete;
        }

        // =====================================
        // LED DISPLAY RENDERING
        // =====================================

        // Helper function to wrap text on canvas
        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const testLine = currentLine + ' ' + words[i];
                const metrics = ctx.measureText(testLine);

                if (metrics.width > maxWidth) {
                    lines.push(currentLine);
                    currentLine = words[i];
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        function renderLEDDisplay(athlete) {
            if (!athlete) {
                clearLEDDisplay();
                return;
            }

            console.log('Rendering athlete:', athlete);
            console.log('Gender place:', athlete.gender_place);
            console.log('Division place:', athlete.division_place);
            console.log('Bracket positions:', athlete.bracket_positions);
            console.log('Bracket name:', athlete.bracket_name);
            console.log('Club:', athlete.club);

            const canvas = ui.ledCanvas;
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, 240, 240);

            ctx.textAlign = 'center';

            // Policz ile kategorii bƒôdzie wy≈õwietlanych
            const categoriesToShow = [];
            console.log('üîç CATEGORY DEBUG for BIB', athlete.bib_num);
            console.log('bracket_positions:', athlete.bracket_positions);
            console.log('config.display.showAge:', config.display.showAge);
            console.log('config.display.showCustom:', config.display.showCustom);

            if (athlete.bracket_positions && typeof athlete.bracket_positions === 'object') {
                for (const [bracketName, position] of Object.entries(athlete.bracket_positions)) {
                    if (!position || position <= 0) continue;
                    const isAge = isAgeBracket(bracketName);
                    const isSex = isSexBracket(bracketName);
                    console.log(`  Category "${bracketName}": position=${position}, isAge=${isAge}, isSex=${isSex}`);

                    if (isSex) {
                        console.log(`    ‚ùå Skipped (sex bracket)`);
                        continue;
                    }
                    if ((isAge && config.display.showAge) || (!isAge && !isSex && config.display.showCustom)) {
                        console.log(`    ‚úÖ Added to display`);
                        categoriesToShow.push({ name: bracketName, place: position });
                    } else {
                        console.log(`    ‚ùå Not added (showAge=${config.display.showAge}, showCustom=${config.display.showCustom})`);
                    }
                }
            } else if (athlete.bracket_name && athlete.division_place) {
                const isAge = isAgeBracket(athlete.bracket_name);
                const isSex = isSexBracket(athlete.bracket_name);
                console.log(`  Single category "${athlete.bracket_name}": isAge=${isAge}, isSex=${isSex}`);
                if (!isSex && ((isAge && config.display.showAge) || (!isAge && config.display.showCustom))) {
                    console.log(`    ‚úÖ Added to display`);
                    categoriesToShow.push({ name: athlete.bracket_name, place: athlete.division_place });
                } else {
                    console.log(`    ‚ùå Not added`);
                }
            }
            console.log('üìä Final categoriesToShow:', categoriesToShow);

            // Ustal wiƒôksze sta≈Çe rozmiary czcionek
            const fontSize = {
                event: 18,
                location: 11,
                distance: 11,
                name: 22,
                club: 13,
                time: 18,
                category: 16
            };

            const maxTextWidth = 238; // Canvas width (240px) minus small margins

            // Sprawd≈∫ wrapping z tymi rozmiarami - zmniejsz czcionkƒô gdy za d≈Çuga
            let eventNameLines = 1;
            if (cache.eventInfo && cache.eventInfo.event_name) {
                ctx.font = `bold ${fontSize.event}px Arial`;
                let lines = wrapText(ctx, cache.eventInfo.event_name, maxTextWidth);
                // Je≈õli nazwa zajmuje > 2 linie, zmniejsz czcionkƒô (preferujemy 2 linie max)
                while (lines.length > 2 && fontSize.event > 10) {
                    fontSize.event -= 1;
                    ctx.font = `bold ${fontSize.event}px Arial`;
                    lines = wrapText(ctx, cache.eventInfo.event_name, maxTextWidth);
                }
                eventNameLines = lines.length;
            }

            const athleteName = `${athlete.athlete_first_name} ${athlete.athlete_last_name}`;
            ctx.font = `bold ${fontSize.name}px Arial`;
            let nameLines = wrapText(ctx, athleteName, maxTextWidth);
            // Je≈õli nazwisko zajmuje > 2 linie, zmniejsz czcionkƒô
            while (nameLines.length > 2 && fontSize.name > 16) {
                fontSize.name -= 1;
                ctx.font = `bold ${fontSize.name}px Arial`;
                nameLines = wrapText(ctx, athleteName, maxTextWidth);
            }
            const athleteNameLines = nameLines.length;

            // Policz rzeczywistƒÖ liczbƒô linii Z wrappingiem
            let lineCount = 0;
            lineCount += eventNameLines;
            if (config.display.showLocation && cache.eventInfo && cache.eventInfo.location_city) lineCount++;
            if (config.display.showDistance && athlete.race_distance) lineCount++;
            lineCount += athleteNameLines;
            if (config.display.showClub && athlete.club) lineCount++;
            lineCount += (config.display.showNetTime && config.display.showGunTime) ? 2 : 1;
            if (config.display.showOverall && athlete.overall_place) lineCount++;
            if (config.display.showGender && athlete.gender_place) lineCount++;
            lineCount += Math.min(categoriesToShow.length, 5);

            // Footer zajmuje wiƒôcej miejsca gdy jest custom text
            const hasCustomFooter = config.display.customFooterText && config.display.customFooterText.trim();
            const footerHeight = hasCustomFooter ? 35 : 30; // 3 linie + custom vs 2 linie (YO&GO + wyniki)

            // Oblicz lineHeight aby wszystko siƒô zmie≈õci≈Ço
            const topMargin = 20; // WystarczajƒÖcy margines dla najwiƒôkszej czcionki
            const availableHeight = 240 - footerHeight - topMargin; // Canvas height minus footer and top margin
            let lineHeight = Math.floor(availableHeight / lineCount);

            // POPRAWKA: 0.85 dla polskich znak√≥w diakrytycznych (≈º,≈∫,ƒá,ƒô,ƒÖ)
            // Kreska nad ≈ª/≈π/ƒÜ i ogonek ƒò/ƒÑ wymagajƒÖ wiƒôcej przestrzeni
            lineHeight = Math.floor(lineHeight * 0.85);

            // STA≈ÅY lineHeight dla nazwy biegu (nie zale≈ºy od d≈Çugo≈õci imienia)
            const eventLineHeight = 19; // Zwiƒôkszony z 16 aby uniknƒÖƒá nachodzenia przy 3-liniowej nazwie

            // Je≈õli lineHeight wychodzi za ma≈Çy, proporcjonalnie zmniejsz czcionki
            // UWAGA: NIE skalujemy fontSize.event - nazwa biegu zawsze tego samego rozmiaru
            if (lineHeight < 14) {
                const scale = lineHeight / 14;
                // fontSize.event NIE skalowany - zawsze 14px
                fontSize.location = Math.max(8, Math.floor(fontSize.location * scale));
                fontSize.distance = Math.max(8, Math.floor(fontSize.distance * scale));
                fontSize.name = Math.max(12, Math.floor(fontSize.name * scale));
                fontSize.club = Math.max(9, Math.floor(fontSize.club * scale));
                fontSize.time = Math.max(10, Math.floor(fontSize.time * scale));
                fontSize.category = Math.max(9, Math.floor(fontSize.category * scale));
                lineHeight = Math.max(12, lineHeight);
            }

            // Cap at reasonable maximum
            if (lineHeight > 20) lineHeight = 20;

            let y = topMargin; // Start z prawid≈Çowym marginesem

            // 1. Event name (nazwa biegu) - with wrapping, STA≈ÅY lineHeight
            if (cache.eventInfo && cache.eventInfo.event_name) {
                ctx.font = `bold ${fontSize.event}px Arial`;
                ctx.fillStyle = '#FFD700'; // Z≈Çoty
                const lines = wrapText(ctx, cache.eventInfo.event_name, maxTextWidth);
                lines.forEach(line => {
                    ctx.fillText(line, 120, y);
                    y += eventLineHeight; // U≈ºyj sta≈Çego eventLineHeight zamiast dynamicznego lineHeight
                });

                // Dodaj odstƒôp po nazwie biegu TYLKO gdy NIE MA dystansu/miejscowo≈õci
                const hasDistanceOrLocation = (config.display.showDistance && athlete.race_distance) ||
                                             (config.display.showLocation && cache.eventInfo && cache.eventInfo.location_city);
                if (!hasDistanceOrLocation) {
                    y += 2; // Ma≈Çy odstƒôp miƒôdzy nazwƒÖ biegu a nazwiskiem
                }
            }

            // 2. Distance (dystans) - DRUGA POZYCJA jako opcja
            if (config.display.showDistance && athlete.race_distance) {
                ctx.font = `${fontSize.distance}px Arial`;
                ctx.fillStyle = '#FF0000'; // Czerwony
                ctx.fillText(athlete.race_distance, 120, y);
                y += lineHeight;

                // Je≈õli NIE MA miejscowo≈õci, dodaj odstƒôp (≈ºeby nie nachodziƒá na nazwisko)
                const hasLocation = config.display.showLocation && cache.eventInfo && cache.eventInfo.location_city;
                if (!hasLocation) {
                    y += 5;
                }
            }

            // 3. Location (miejscowo≈õƒá) - if configured
            if (config.display.showLocation && cache.eventInfo && cache.eventInfo.location_city) {
                ctx.font = `${fontSize.location}px Arial`;
                ctx.fillStyle = '#FFD700'; // ≈ª√≥≈Çty
                ctx.fillText(cache.eventInfo.location_city, 120, y);
                y += lineHeight;
                y += 5; // Wiƒôkszy odstƒôp po miejscowo≈õci (≈ºeby nie nachodziƒá na nazwisko)
            }

            // 4. Imiƒô nazwisko - with wrapping
            ctx.font = `bold ${fontSize.name}px Arial`;
            ctx.fillStyle = '#FFFFFF'; // Bia≈Çy - odr√≥≈ºnia siƒô od nazwy biegu
            let wrappedNameLines = wrapText(ctx, athleteName, maxTextWidth);
            wrappedNameLines.forEach(line => {
                ctx.fillText(line, 120, y);
                y += lineHeight;
            });

            // Warunkowy odstƒôp po nazwisku: wiƒôkszy gdy nazwisko na 2 liniach i jest klub
            const hasClub = config.display.showClub && athlete.club;
            const isNameWrapped = wrappedNameLines.length > 1;
            if (isNameWrapped && hasClub) {
                y += 6; // Wiƒôkszy odstƒôp dla 2-liniowego nazwiska z klubem
            } else {
                y += 4; // Standardowy odstƒôp
            }

            // 5. Club (klub)
            if (config.display.showClub && athlete.club) {
                ctx.font = `${fontSize.club}px Arial`;
                ctx.fillStyle = '#00BFFF'; // Jasnoniebieski - lepszy widoczny ni≈º szary
                ctx.fillText(athlete.club, 120, y);
                y += lineHeight;
                y += 5; // Wiƒôkszy odstƒôp po klubie przed czasami
            }

            // 6. Czasy - WYNIK (brutto) i NETTO
            ctx.fillStyle = '#00FF00';
            ctx.font = `bold ${fontSize.time}px Arial`;

            const showBothTimes = config.display.showNetTime && config.display.showGunTime;

            if (showBothTimes) {
                // Show WYNIK (brutto) and NETTO
                if (athlete.formatted_gun_time) {
                    ctx.fillText(`WYNIK: ${athlete.formatted_gun_time}`, 120, y);
                    y += lineHeight;
                    y += 3; // Wiƒôkszy odstƒôp miƒôdzy WYNIK i NETTO
                }
                if (athlete.formatted_net_time) {
                    ctx.fillText(`NETTO: ${athlete.formatted_net_time}`, 120, y);
                    y += lineHeight;
                }
            } else if (config.display.showNetTime && athlete.formatted_net_time) {
                // Show only NETTO as WYNIK
                ctx.fillText(`WYNIK: ${athlete.formatted_net_time}`, 120, y);
                y += lineHeight;
            } else if (config.display.showGunTime && athlete.formatted_gun_time) {
                // Show only BRUTTO as WYNIK
                ctx.fillText(`WYNIK: ${athlete.formatted_gun_time}`, 120, y);
                y += lineHeight;
            }

            // 7. Miejsca w kategoriach
            ctx.fillStyle = '#FF8C00';
            ctx.font = `bold ${fontSize.category}px Arial`;

            // OPEN place
            if (config.display.showOverall && athlete.overall_place) {
                ctx.fillText(`OPEN: ${athlete.overall_place}`, 120, y);
                y += lineHeight;

                // Dodatkowy odstƒôp miƒôdzy OPEN a Mƒò≈ªCZY≈πNI (tylko gdy sƒÖ dystans i miejscowo≈õƒá)
                const hasDistanceAndLocation = config.display.showDistance && athlete.race_distance &&
                                              config.display.showLocation && cache.eventInfo && cache.eventInfo.location_city;
                if (hasDistanceAndLocation) {
                    y += 3;
                }
            }

            // K/M place
            if (config.display.showGender && athlete.gender_place) {
                const genderLabel = athlete.athlete_sex === 'M' ? 'Mƒò≈ªCZY≈πNI' : 'KOBIETY';
                ctx.fillText(`${genderLabel}: ${athlete.gender_place}`, 120, y);
                y += lineHeight;
            }

            // Wy≈õwietl kategorie (max 5 ≈ºeby siƒô zmie≈õci≈Ço)
            categoriesToShow.slice(0, 5).forEach(cat => {
                ctx.fillText(`${cat.name}: ${cat.place}`, 120, y);
                y += lineHeight;
            });

            // Footer - DU≈ªY i wype≈Çnia pozosta≈Çe 15% ekranu
            // Opcjonalny tekst u≈ºytkownika (je≈õli jest)
            if (config.display.customFooterText && config.display.customFooterText.trim()) {
                ctx.font = 'bold 11px Arial';
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText(config.display.customFooterText, 120, 212);
            }

            // YO&GO Events - pomiar czasu
            ctx.font = 'bold 11px Arial';
            ctx.fillStyle = '#FF8C00';
            ctx.fillText('YO&GO Events - pomiar czasu', 120, 225);

            // wyniki www.yogoevents.pl
            ctx.font = '10px Arial';
            ctx.fillStyle = '#FF8C00';
            ctx.fillText('wyniki www.yogoevents.pl', 120, 237);

            selectedAthlete = athlete;

            // Send to LED if configured
            sendToLED();
        }

        function clearLEDDisplay() {
            const canvas = ui.ledCanvas;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, 240, 240);

            ctx.fillStyle = '#888';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Oczekiwanie na dane...', 120, 120);

            selectedAthlete = null;
            ui.displayStatus.textContent = '';
        }

        // =====================================
        // LED WINDOW FOR HDMI DISPLAY - AUTOMATIC
        // =====================================

        async function openLEDWindow() {
            // Je≈õli okno ju≈º otwarte, zamknij stare
            if (ledWindow && !ledWindow.closed) {
                ledWindow.close();
            }

            try {
                // U≈ºyj Window Placement API aby wykryƒá drugi monitor
                if ('getScreenDetails' in window) {
                    const screens = await window.getScreenDetails();
                    const secondScreen = screens.screens.length > 1 ? screens.screens[1] : screens.screens[0];

                    // Otw√≥rz fullscreen na drugim monitorze
                    ledWindow = window.open(
                        '',
                        'LED_Display',
                        `left=${secondScreen.left},top=${secondScreen.top},width=${secondScreen.width},height=${secondScreen.height},toolbar=no,location=no,status=no,menubar=no,scrollbars=no,fullscreen=yes`
                    );
                } else {
                    // Fallback - otw√≥rz po prawej stronie
                    ledWindow = window.open(
                        '',
                        'LED_Display',
                        `left=${window.screen.width},top=0,width=1024,height=768,toolbar=no,location=no,status=no,menubar=no,scrollbars=no`
                    );
                }
            } catch (error) {
                console.error('Could not use Window Placement API:', error);
                // Fallback
                ledWindow = window.open(
                    '',
                    'LED_Display',
                    `left=${window.screen.width},top=0,width=1024,height=768,toolbar=no,location=no,status=no,menubar=no,scrollbars=no`
                );
            }

            if (!ledWindow) {
                alert('Nie mo≈ºna otworzyƒá okna LED. Sprawd≈∫ czy przeglƒÖdarka nie blokuje popup.');
                return;
            }

            // Wygeneruj HTML dla okna LED - pe≈Çny ekran czarny, sam canvas
            ledWindow.document.write(`
<!DOCTYPE html>
<html>
<head>
    <title>LED Display - 240√ó240px (96cm√ó96cm P4)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: none;
        }
        #led-canvas {
            /* Pixelated rendering - ostre krawƒôdzie jak fizyczna tablica LED P4 */
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;

            /* Wype≈Çnij ca≈Çy dostƒôpny ekran LED */
            width: 100%;
            height: 100%;

            /* RozciƒÖgnij do pe≈Çnego rozmiaru (tablica jest kwadratowa wiƒôc OK) */
            object-fit: fill;
        }
    </style>
</head>
<body>
    <canvas id="led-canvas" width="240" height="240"></canvas>
    <script>
        // Auto fullscreen - maksymalizuje obraz LED
        function enterFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen()
                    .then(() => console.log('Fullscreen: ON - LED Display 240√ó240px scaled to full screen'))
                    .catch(err => console.error('Fullscreen error:', err));
            }
        }

        // Automatycznie fullscreen po 100ms
        setTimeout(enterFullscreen, 100);

        // Backup - klikniƒôcie te≈º w≈ÇƒÖcza fullscreen
        document.addEventListener('click', enterFullscreen);

        // Info dla developera
        console.log('LED Display Window Ready');
        console.log('Physical: 96cm √ó 96cm, P4 (4mm pitch)');
        console.log('Resolution: 240 √ó 240 pixels');
        console.log('Canvas scaled to full screen with pixelated rendering');
    <\/script>
</body>
</html>
            `);
            ledWindow.document.close();

            // Synchronizuj canvas
            syncLEDWindow();

            console.log('LED window opened automatically');
        }

        function syncLEDWindow() {
            if (!ledWindow || ledWindow.closed) return;

            try {
                const sourceCanvas = ui.ledCanvas;
                const targetCanvas = ledWindow.document.getElementById('led-canvas');

                if (targetCanvas && sourceCanvas) {
                    const targetCtx = targetCanvas.getContext('2d');
                    targetCtx.drawImage(sourceCanvas, 0, 0);
                }
            } catch (error) {
                console.error('LED window sync error:', error);
            }
        }

        function sendToLED() {
            if (!selectedAthlete) {
                if (ui.displayStatus) ui.displayStatus.textContent = '';
                return;
            }

            const connectionType = config.led.connectionType;

            // Poka≈º napis "Wy≈õwietlono" zawsze gdy wy≈õwietlamy zawodnika
            if (ui.displayStatus) {
                ui.displayStatus.textContent = 'WY≈öWIETLONO';
                ui.displayStatus.style.display = 'block';
            }

            // Synchronizuj z oknem LED je≈õli jest otwarte
            syncLEDWindow();

            if (connectionType === 'none') {
                // Only preview, no actual sending
                updateIndicator('led-indicator', 'led-status', true, 'LED: Tylko podglƒÖd');
                return;
            }

            if (connectionType === 'hdmi') {
                // HDMI mode - canvas is already displayed, user should press F11 for fullscreen
                updateIndicator('led-indicator', 'led-status', true, 'LED: HDMI (naci≈õnij F11)');
                return;
            }

            if (connectionType === 'ethernet') {
                // Send to LED via Ethernet/HTTP
                sendToLEDViaEthernet();
            }
        }

        async function sendToLEDViaEthernet() {
            try {
                const canvas = ui.ledCanvas;
                const imageData = canvas.toDataURL('image/png');

                // Send image to Node.js bridge server (which forwards to LED via TCP)
                // Bridge server must be running: node led-bridge-server.js
                const response = await fetch('http://localhost:3000/send-to-led', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image: imageData,
                        ledIP: config.led.ip,
                        ledPort: parseInt(config.led.port)
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('LED response:', result);
                    updateIndicator('led-indicator', 'led-status', true, 'LED: Wys≈Çano przez TCP');
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'HTTP Error: ' + response.status);
                }
            } catch (error) {
                console.error('Send to LED error:', error);
                updateIndicator('led-indicator', 'led-status', false, 'LED: B≈ÇƒÖd - ' + error.message);
            }
        }

        // =====================================
        // RFID FUNCTIONS (KEYBOARD EMULATION MODE)
        // =====================================
        // Czytniki USB RFID w trybie HID zachowujƒÖ siƒô jak klawiatura:
        // 1. Klikasz w pole input
        // 2. Zbli≈ºasz opaskƒô do czytnika
        // 3. Czytnik "wpisuje" TAG i naciska Enter
        // 4. Aplikacja ≈Çapie Enter i wy≈õwietla wynik

        let rfidBuffer = '';
        let rfidTimeout = null;

        function initRFIDKeyboardMode() {
            console.log('RFID Keyboard Mode: Initialized');

            // Status jako gotowy
            config.rfid.connected = true;
            updateIndicator('rfid-indicator', 'rfid-status', true, 'RFID: Gotowy');
            updateIndicator('admin-rfid-indicator', 'admin-rfid-status', true, 'Gotowy: Oczekiwanie na TAG');

            // Nas≈Çuchuj na klawiaturƒô gdy focus na search input
            ui.searchInput.addEventListener('keydown', handleRFIDKeydown);

            // Nas≈Çuchuj na input (zbiera TAG znak po znaku)
            ui.searchInput.addEventListener('input', handleRFIDInput);
        }

        function handleRFIDKeydown(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                const tagId = ui.searchInput.value.trim();

                if (tagId.length > 0) {
                    console.log(`üè∑Ô∏è RFID TAG detected: ${tagId}`);
                    handleRFIDTag(tagId);
                }
            }
        }

        function handleRFIDInput(e) {
            // Czytnik USB wpisuje TAG bardzo szybko (< 100ms)
            // Cz≈Çowiek pisze wolniej - mo≈ºemy to rozpoznaƒá
            clearTimeout(rfidTimeout);

            rfidTimeout = setTimeout(() => {
                // Je≈õli input jest d≈Çu≈ºszy ni≈º 8 znak√≥w i by≈Ç wpisany szybko,
                // prawdopodobnie to RFID (nie cz≈Çowiek)
                const value = ui.searchInput.value.trim();
                if (value.length >= 8) {
                    console.log(`‚ö° Fast input detected (likely RFID): ${value}`);
                    // Mo≈ºemy tu dodaƒá auto-submit po wykryciu szybkiego inputu
                }
            }, 150);
        }

        async function handleRFIDTag(tagId) {
            // Zapisz ostatnio odczytany TAG
            const lastTagInput = document.getElementById('last-rfid-tag');
            if (lastTagInput) {
                lastTagInput.value = tagId;
            }

            // Zmie≈Ñ status na "Odczytano"
            updateIndicator('rfid-indicator', 'rfid-status', true, `RFID: Odczytano ${tagId}`);
            updateIndicator('admin-rfid-indicator', 'admin-rfid-status', true, `Odczytano: ${tagId}`);

            // Find BIB for this TAG
            const bib = cache.tags[tagId];

            if (bib) {
                console.log(`‚úÖ TAG ${tagId} -> BIB ${bib}`);
                ui.searchInput.value = bib;
                await searchAndDisplay(bib);

                // Po 2 sekundach wr√≥ƒá do statusu "Gotowy"
                setTimeout(() => {
                    updateIndicator('rfid-indicator', 'rfid-status', true, 'RFID: Gotowy');
                    updateIndicator('admin-rfid-indicator', 'admin-rfid-status', true, 'Gotowy: Oczekiwanie na TAG');
                }, 2000);
            } else {
                console.log(`TAG ${tagId} not found in cache`);
                showStatus('search-status', `TAG ${tagId} nie znaleziony`, 'error');
            }
        }

        // =====================================
        // SEARCH AND DISPLAY
        // =====================================

        async function searchAndDisplay(bib) {
            if (!bib) {
                showStatus('search-status', 'Wprowad≈∫ numer startowy', 'error');
                return;
            }

            showStatus('search-status', 'Szukam...', '');

            try {
                const athlete = await findAthleteByBib(bib);

                if (athlete) {
                    showStatus('search-status', `Znaleziono: ${athlete.athlete_first_name} ${athlete.athlete_last_name}`, 'success');
                    renderLEDDisplay(athlete);
                } else {
                    showStatus('search-status', 'Nie znaleziono zawodnika', 'error');
                    clearLEDDisplay();
                }
            } catch (error) {
                showStatus('search-status', `B≈ÇƒÖd: ${error.message}`, 'error');
                clearLEDDisplay();
            }
        }

        // =====================================
        // MODE TOGGLE
        // =====================================

        function toggleMode() {
            if (currentMode === 'display') {
                // Going from DISPLAY to ADMIN - require password
                showPasswordModal();
            } else {
                // Going from ADMIN to DISPLAY - no password needed
                switchToDisplayMode();
            }
        }

        function showPasswordModal() {
            ui.passwordModal.classList.add('active');
            ui.adminPasswordInput.value = '';
            ui.adminPasswordInput.focus();
            ui.passwordError.style.display = 'none';
        }

        function hidePasswordModal() {
            ui.passwordModal.classList.remove('active');
            ui.adminPasswordInput.value = '';
            ui.passwordError.style.display = 'none';
        }

        function checkPassword() {
            const enteredPassword = ui.adminPasswordInput.value;

            if (enteredPassword === ADMIN_PASSWORD) {
                hidePasswordModal();
                switchToAdminMode();
            } else {
                showStatus('password-error', 'Nieprawid≈Çowe has≈Ço', 'error');
            }
        }

        function switchToAdminMode() {
            currentMode = 'admin';
            ui.displayScreen.classList.remove('active');
            ui.adminScreen.classList.add('active');
            ui.modeToggle.textContent = 'üëÅÔ∏è Wy≈õwietl';

            // Remove display-mode class
            document.body.classList.remove('display-mode');
            document.querySelector('.container').classList.remove('display-mode');
        }

        function switchToDisplayMode() {
            currentMode = 'display';
            ui.adminScreen.classList.remove('active');
            ui.displayScreen.classList.add('active');
            ui.modeToggle.textContent = '‚öôÔ∏è';

            // Add display-mode class for fullscreen black background
            document.body.classList.add('display-mode');
            document.querySelector('.container').classList.add('display-mode');

            // Focus search input
            setTimeout(() => ui.searchInput.focus(), 100);
        }

        // =====================================
        // CONFIGURATION SAVE/LOAD
        // =====================================

        function saveApiConfig() {
            const eventId = ui.eventIdInput.value.trim();

            if (!eventId) {
                showStatus('api-save-status', 'Wprowad≈∫ ID wydarzenia', 'error');
                return;
            }

            // Check if eventId has changed - if so, clear all cached data
            if (config.api.eventId && config.api.eventId !== eventId) {
                console.log('EventId changed from', config.api.eventId, 'to', eventId, '- clearing cache');

                // Clear all cached data
                cache.athletes = {};
                cache.openResults = [];
                cache.sexResults = { M: [], F: [] };
                cache.ageResults = {};
                cache.customResults = {};
                cache.clubs = {};
                cache.tags = {};
                cache.eventInfo = null;
                cache.persistentData.genderPlaces = {};
                cache.persistentData.divisionPlaces = {};

                // Clear selected athlete
                selectedAthlete = null;
                clearLEDDisplay();

                showStatus('api-save-status', 'Zmieniono wydarzenie - czyszczenie cache...', 'success');
            }

            config.api.eventId = eventId;
            localStorage.setItem('led-event-id', eventId);

            showStatus('api-save-status', 'Zapisano. ≈ÅƒÖczƒô z API...', 'success');

            // Connect to API and refresh data
            initializeApi();
        }

        function saveDisplayConfig() {
            config.display.showLocation = ui.showLocation.checked;
            config.display.showDistance = ui.showDistance.checked;
            config.display.showClub = ui.showClub.checked;
            config.display.showNetTime = ui.showNetTime.checked;
            config.display.showGunTime = ui.showGunTime.checked;
            config.display.showOverall = ui.showOverall.checked;
            config.display.showGender = ui.showGender.checked;
            config.display.showAge = ui.showAge.checked;
            config.display.showCustom = ui.showCustom.checked;
            config.display.customFooterText = ui.customFooterText.value.trim();

            localStorage.setItem('led-show-location', config.display.showLocation);
            localStorage.setItem('led-show-distance', config.display.showDistance);
            localStorage.setItem('led-show-club', config.display.showClub);
            localStorage.setItem('led-show-net-time', config.display.showNetTime);
            localStorage.setItem('led-show-gun-time', config.display.showGunTime);
            localStorage.setItem('led-show-overall', config.display.showOverall);
            localStorage.setItem('led-show-gender', config.display.showGender);
            localStorage.setItem('led-show-age', config.display.showAge);
            localStorage.setItem('led-show-custom', config.display.showCustom);
            localStorage.setItem('led-custom-footer-text', config.display.customFooterText);

            alert('Ustawienia wy≈õwietlania zapisane');

            // Re-render current athlete if any
            if (selectedAthlete) {
                renderLEDDisplay(selectedAthlete);
            }
        }

        function saveLedConfig() {
            config.led.connectionType = ui.ledConnectionType.value;
            config.led.ip = ui.ledIp.value;
            config.led.port = ui.ledPort.value;

            localStorage.setItem('led-connection-type', config.led.connectionType);
            localStorage.setItem('led-ip', config.led.ip);
            localStorage.setItem('led-port', config.led.port);

            alert('Konfiguracja LED zapisana');

            // Update status
            if (config.led.connectionType === 'none') {
                updateIndicator('led-indicator', 'led-status', true, 'LED: Tylko podglƒÖd');
            } else if (config.led.connectionType === 'hdmi') {
                updateIndicator('led-indicator', 'led-status', true, 'LED: HDMI');
            } else if (config.led.connectionType === 'ethernet') {
                updateIndicator('led-indicator', 'led-status', false, 'LED: Ethernet (niepo≈ÇƒÖczony)');
            }
        }

        async function testLedConnection() {
            if (config.led.connectionType === 'ethernet') {
                // Test connection to Node.js bridge server (not directly to LED!)
                try {
                    const response = await fetch('http://localhost:3000/status');
                    if (response.ok) {
                        const data = await response.json();
                        alert(`‚úÖ Bridge server dzia≈Ça!\n\n${data.message}\n\nKonfiguracja:\nLED IP: ${config.led.ip}\nLED Port: ${config.led.port}\n\nTeraz wy≈õwietl zawodnika aby przetestowaƒá po≈ÇƒÖczenie TCP z tablicƒÖ.`);
                        updateIndicator('led-indicator', 'led-status', true, 'LED: Bridge server gotowy');
                    } else {
                        throw new Error('Bridge server nie odpowiada');
                    }
                } catch (error) {
                    alert(`‚ùå Nie mo≈ºna po≈ÇƒÖczyƒá siƒô z bridge serverem!\n\nUpewnij siƒô ≈ºe Node.js server dzia≈Ça:\n\nnode led-bridge-server.js\n\nB≈ÇƒÖd: ${error.message}`);
                    updateIndicator('led-indicator', 'led-status', false, 'LED: Bridge server offline');
                }
            } else if (config.led.connectionType === 'hdmi') {
                alert('‚úÖ Tryb HDMI aktywny\n\nWy≈õwietl zawodnika i naci≈õnij F11 dla fullscreen');
                updateIndicator('led-indicator', 'led-status', true, 'LED: HDMI gotowy');
            } else {
                alert('‚ö†Ô∏è Wybierz typ po≈ÇƒÖczenia LED w konfiguracji');
            }
        }

        function loadConfig() {
            // Load saved config
            if (config.api.eventId) {
                ui.eventIdInput.value = config.api.eventId;
            }

            ui.showLocation.checked = config.display.showLocation;
            ui.showDistance.checked = config.display.showDistance;
            ui.showClub.checked = config.display.showClub;
            ui.showNetTime.checked = config.display.showNetTime;
            ui.showGunTime.checked = config.display.showGunTime;
            ui.showOverall.checked = config.display.showOverall;
            ui.showGender.checked = config.display.showGender;
            ui.showAge.checked = config.display.showAge;
            ui.showCustom.checked = config.display.showCustom;
            ui.customFooterText.value = config.display.customFooterText || '';

            ui.ledConnectionType.value = config.led.connectionType;
            ui.ledIp.value = config.led.ip;
            ui.ledPort.value = config.led.port;

            updateLedConnectionUI();
        }

        function updateLedConnectionUI() {
            if (ui.ledConnectionType.value === 'ethernet') {
                ui.ethernetConfig.classList.remove('hidden');
            } else {
                ui.ethernetConfig.classList.add('hidden');
            }
        }


        // =====================================
        // API INITIALIZATION
        // =====================================

        async function initializeApi() {
            try {
                if (config.api.eventId) {
                    updateIndicator('api-indicator', 'api-status', false, 'API: ≈ÅƒÖczenie...');

                    const success = await refreshAllData();

                    if (success) {
                        setupRefreshTimer();
                        return true;
                    } else {
                        updateIndicator('api-indicator', 'api-status', false, 'API: B≈ÇƒÖd po≈ÇƒÖczenia');
                        return false;
                    }
                } else {
                    updateIndicator('api-indicator', 'api-status', false, 'API: Brak konfiguracji');
                    return false;
                }
            } catch (error) {
                updateIndicator('api-indicator', 'api-status', false, 'API: B≈ÇƒÖd');
                return false;
            }
        }

        // =====================================
        // CURSOR LOCK (Bezobs≈Çugowe - blokada kursora)
        // =====================================

        let cursorLocked = false;

        function lockCursor() {
            if (!cursorLocked && ui.lockCursorCheckbox.checked) {
                document.body.requestPointerLock();
            }
        }

        function unlockCursor() {
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }

        function updateCursorLockUI() {
            cursorLocked = !!document.pointerLockElement;
            ui.lockCursorCheckbox.checked = cursorLocked;

            if (cursorLocked) {
                console.log('üîí Kursor zablokowany - nie mo≈ºna wyjechaƒá na drugi ekran');
                // Auto-focus na input po zablokowaniu - od razu gotowe do wpisywania
                ui.searchInput.focus();
            } else {
                console.log('üîì Kursor odblokowany');
            }
        }

        // Nas≈Çuchuj zmian pointer lock
        document.addEventListener('pointerlockchange', updateCursorLockUI);
        document.addEventListener('pointerlockerror', () => {
            console.error('Nie mo≈ºna zablokowaƒá kursora');
            ui.lockCursorCheckbox.checked = false;
        });

        // =====================================
        // EVENT LISTENERS
        // =====================================

        ui.modeToggle.addEventListener('click', toggleMode);

        // Checkbox blokowania kursora
        ui.lockCursorCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                lockCursor();
            } else {
                unlockCursor();
            }
        });

        // Skr√≥t klawiszowy: Ctrl+Alt+L = odblokuj kursor
        document.addEventListener('keydown', (e) => {
            // U≈ºyj e.code zamiast e.key - dzia≈Ça niezale≈ºnie od Shift/CapsLock
            if (e.ctrlKey && e.altKey && e.code === 'KeyL') {
                e.preventDefault();
                unlockCursor();
                ui.lockCursorCheckbox.checked = false;
                console.log('üîì Kursor odblokowany przez skr√≥t Ctrl+Alt+L');
            }
        });

        ui.searchBtn.addEventListener('click', () => {
            const bib = ui.searchInput.value.trim();
            searchAndDisplay(bib);
            // Auto-kasowanie po wy≈õwietleniu - kolejny zawodnik nie musi u≈ºywaƒá backspace
            ui.searchInput.value = '';
            ui.searchInput.focus(); // Przywr√≥ƒá focus do inputa
        });

        ui.searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const bib = ui.searchInput.value.trim();
                searchAndDisplay(bib);
                // Auto-kasowanie po wy≈õwietleniu - kolejny zawodnik nie musi u≈ºywaƒá backspace
                ui.searchInput.value = '';
            }
        });

        ui.saveApiBtn.addEventListener('click', saveApiConfig);
        ui.refreshCacheBtn.addEventListener('click', refreshAllData);
        ui.saveDisplayBtn.addEventListener('click', saveDisplayConfig);
        ui.saveLedBtn.addEventListener('click', saveLedConfig);
        ui.testLedBtn.addEventListener('click', testLedConnection);
        ui.openLedWindowBtn.addEventListener('click', openLEDWindow);

        ui.ledConnectionType.addEventListener('change', updateLedConnectionUI);

        // Password modal
        ui.submitPasswordBtn.addEventListener('click', checkPassword);
        ui.cancelPasswordBtn.addEventListener('click', hidePasswordModal);
        ui.adminPasswordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') checkPassword();
        });

        // =====================================
        // INITIALIZATION
        // =====================================

        console.log('LED Display System v2 - Initializing...');

        loadConfig();
        clearLEDDisplay();

        // Initialize API if configured
        if (config.api.eventId) {
            initializeApi();
        } else {
            updateIndicator('api-indicator', 'api-status', false, 'API: Skonfiguruj ID wydarzenia');
        }

        // Initialize RFID Keyboard Mode
        initRFIDKeyboardMode();
        updateIndicator('led-indicator', 'led-status', true, 'LED: Gotowy');

        // Focus search input
        ui.searchInput.focus();

        console.log('LED Display System v2 - Ready!');
    });
    </script>
</body>
</html>
